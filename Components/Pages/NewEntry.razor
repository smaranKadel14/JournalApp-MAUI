@*
    New Entry Page - Journal Entry Creation/Editing Component
    ====================================================
    Purpose: Create new journal entries or edit existing ones
    
    Features:
    - Rich text editor for content creation
    - Mood selection (primary and secondary moods)
    - Tag management system
    - Entry metadata (title, date, category)
    - Delete functionality for existing entries
*@
@page "/new-entry"
@page "/new-entry/{EntryId:int}"

@using System.Linq
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.EntityFrameworkCore
@using Microsoft.JSInterop
@using JournalApp.Models
@using JournalApp.Components.Shared

@inject IJSRuntime JS
@inject JournalApp.Services.UserService UserSession
@inject JournalApp.Data.AppDbContext DB
@inject NavigationManager Nav

<div class="entry-container">
    <div class="entry-card">
        <!-- Entry Header -->
        <div class="header">
            <button type="button" class="back-link" @onclick="GoBack">← Back</button>

            <h1>@(IsEditMode ? "Edit Entry" : "New Entry")</h1>

            <!-- Header Actions -->
            <div class="header-actions">
                @if (IsEditMode)
                {
                    <button type="button"
                            class="delete-btn"
                            @onclick="ShowDeleteConfirmation"
                            disabled="@IsSaving">
                        Delete
                    </button>
                }

                <button type="button"
                        class="save-btn"
                        @onclick="SaveEntry"
                        disabled="@IsSaving">
                    @(IsSaving ? "Saving..." : "Save")
                </button>
            </div>
        </div>

        <!-- Info Banner -->
        @if (!string.IsNullOrWhiteSpace(InfoMessage))
        {
            <div class="info-banner">
                <div class="info-icon">ℹ️</div>
                <div class="info-content">
                    <div class="info-title">Existing Entry</div>
                    <div class="info-text">@InfoMessage</div>
                </div>
            </div>
        }

        <!-- Entry Metadata -->
        <div class="meta-section">
            <div class="section-subtitle">Entry Information</div>
            <div class="meta-row">
                <div class="meta-item">
                    <span class="meta-label">Created</span>
                    <span class="meta-value">@CreatedAt.ToLocalTime().ToString("g")</span>
                </div>

                <div class="meta-item">
                    <span class="meta-label">Last Updated</span>
                    <span class="meta-value">@UpdatedAt.ToLocalTime().ToString("g")</span>
                </div>
            </div>
        </div>

        <!-- Entry Title Section -->
        <div class="title-section">
            <div class="section-subtitle">Entry Title</div>
            <label class="sr-only">Title</label>
            <input class="title-input"
                   type="text"
                   placeholder="Enter title..."
                   @bind-value="Title"
                   @bind-value:event="oninput"
                   @bind-value:after="TouchUpdated" />
        </div>

        <div class="details-section">
            <div class="section-subtitle">Entry Details</div>
            <div class="row">
                <div class="field">
                    <label>Entry Date</label>

                    <InputDate class="input"
                               Value="EntryDate"
                               ValueChanged="@(async (DateTime d) => await OnEntryDateChanged(d))"
                               ValueExpression="(() => EntryDate)" />
                </div>

                <div class="field">
                    <label>Category</label>

                    <select class="input"
                            @bind="Category"
                            @bind:after="TouchUpdated">
                        @foreach (var c in Categories)
                        {
                            <option value="@c">@c</option>
                        }
                    </select>
                </div>
            </div>
        </div>

        <!-- Mood Selection Component -->
        <div class="component-section">
            <div class="section-title">Mood</div>
            <MoodPicker MoodGroups="MoodGroups"
                        MoodMap="MoodMap"
                        @bind-PrimaryMoodGroup="PrimaryMoodGroup"
                        @bind-SecondaryMoods="SecondaryMoods" />
        </div>

        <!-- Tags Selection Component -->
        <div class="component-section">
            <div class="section-title">Tags</div>
            <TagPicker PrebuiltTags="PrebuiltTags"
                       @bind-SelectedTags="SelectedTags" />
        </div>

        <!-- Content Editor Component -->
        <div class="content-section">
            <div class="section-subtitle">Entry Content</div>
            <div class="field">
                <RichTextEditor @bind-Html="Content" Placeholder="Write your journal entry..." />
            </div>
        </div>

        <!-- Error Message Display -->
        @if (!string.IsNullOrWhiteSpace(ErrorMessage))
        {
            <div class="error-box">@ErrorMessage</div>
        }
    </div>

    <!-- Delete Confirmation Modal -->
    @if (ShowDeleteModal)
    {
        <div class="modal-overlay" @onclick="HideDeleteConfirmation">
            <div class="modal-card" @onclick:stopPropagation>
                <div class="modal-header">
                    <h3>Delete Entry</h3>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete this entry?</p>
                    <p class="modal-warning">This action cannot be undone.</p>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn-cancel" @onclick="HideDeleteConfirmation">
                        Cancel
                    </button>
                    <button type="button" class="btn-delete" @onclick="ConfirmDeleteEntry">
                        Delete Entry
                    </button>
                </div>
            </div>
        </div>
    }
</div>

@code {
    /// Entry ID parameter for edit mode
    [Parameter] public int? EntryId { get; set; }

    /// Indicates whether the component is in edit mode
    private bool IsEditMode => CurrentEntryDbId.HasValue;
    
    /// Database ID of the current entry (if in edit mode)
    private int? CurrentEntryDbId { get; set; } = null;

    /// Entry title
    private string Title { get; set; } = "";
    
    /// Entry date
    private DateTime EntryDate { get; set; } = DateTime.Today;
    
    /// Entry category
    private string Category { get; set; } = "Personal";

    /// Entry content in HTML format
    private string Content { get; set; } = "";

    /// Entry creation timestamp
    private DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    
    /// Entry last updated timestamp
    private DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    /// Available mood groups for selection
    private readonly List<string> MoodGroups = new() { "Positive", "Neutral", "Negative" };

    /// Mapping of mood groups to specific moods
    private readonly Dictionary<string, List<string>> MoodMap = new()
    {
        ["Positive"] = new() { "Happy", "Excited", "Relaxed", "Grateful", "Confident" },
        ["Neutral"]  = new() { "Calm", "Thoughtful", "Curious", "Nostalgic", "Bored" },
        ["Negative"] = new() { "Sad", "Angry", "Stressed", "Lonely", "Anxious" }
    };

    /// Primary mood group selected
    private string PrimaryMoodGroup { get; set; } = "Neutral";
    
    /// List of secondary moods selected
    private List<string> SecondaryMoods { get; set; } = new();

    /// Available categories for selection
    private readonly List<string> Categories = new()
    {
        "Personal", "Work", "Studies", "Family", "Friends", "Health", "Self-care", "Travel", "Finance"
    };

    /// Prebuilt tags for selection
    private readonly List<string> PrebuiltTags = new()
    {
        "Work","Career","Studies","Family","Friends","Relationships","Health","Fitness","Personal Growth","Self-care",
        "Hobbies","Travel","Nature","Finance","Spirituality","Birthday","Holiday","Vacation","Celebration","Exercise",
        "Mental Health","Wellness","Goals","Achievements","Challenges","Learning","Books","Movies","Music","Art",
        "Food","Cooking","Shopping","Technology","Social Media","News","Politics","Weather","Dreams","Memories"
    };

    /// Tags selected for the entry
    private List<string> SelectedTags { get; set; } = new();

    /// Indicates if the entry is currently being saved
    private bool IsSaving { get; set; } = false;
    
    /// Error message displayed to the user
    private string ErrorMessage { get; set; } = "";
    
    /// Information message displayed to the user
    private string InfoMessage { get; set; } = "";
    
    /// Controls the visibility of the delete confirmation modal
    private bool ShowDeleteModal { get; set; } = false;

    /// Strips HTML tags from a string
    /// <param name="html">HTML string to strip</param>
    /// <returns>Plain text string</returns>
    private string StripHtml(string html)
    {
        if (string.IsNullOrWhiteSpace(html)) return "";
        var noTags = System.Text.RegularExpressions.Regex.Replace(html, "<.*?>", string.Empty);
        return System.Net.WebUtility.HtmlDecode(noTags).Trim();
    }

    /// Updates the last modified timestamp
    private void TouchUpdated()
    {
        UpdatedAt = DateTime.UtcNow;
    }

    /// Parses CSV string into a list of strings
    /// <param name="csv">CSV string to parse</param>
    /// <returns>List of individual items</returns>
    private static List<string> SplitCsv(string? csv)
    {
        if (string.IsNullOrWhiteSpace(csv)) return new();
        return csv.Split(',', StringSplitOptions.RemoveEmptyEntries)
                  .Select(x => x.Trim())
                  .Where(x => x.Length > 0)
                  .Distinct()
                  .ToList();
    }

    /// Initializes the component and loads entry data
    protected override async Task OnInitializedAsync()
    {
        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            Nav.NavigateTo("/login");
            return;
        }

        if (EntryId.HasValue)
        {
            await LoadEntryByIdAsync(EntryId.Value);
            return;
        }

        await LoadEntryForDateAsync();
    }

    /// Navigates back to the dashboard
    private void GoBack() => Nav.NavigateTo("/dashboard");

    /// Shows the delete confirmation modal
    private void ShowDeleteConfirmation()
    {
        ShowDeleteModal = true;
    }

    /// Hides the delete confirmation modal
    private void HideDeleteConfirmation()
    {
        ShowDeleteModal = false;
    }

    /// Confirms and executes the entry deletion
    private async Task ConfirmDeleteEntry()
    {
        await DeleteEntry();
    }

    /// Handles entry date change and reloads entry data
    /// <param name="newDate">New entry date</param>
    private async Task OnEntryDateChanged(DateTime newDate)
    {
        EntryDate = newDate.Date;
        await LoadEntryForDateAsync();
    }

    /// Loads entry data for the current entry date
    private async Task LoadEntryForDateAsync()
    {
        ErrorMessage = "";
        InfoMessage = "";
        CurrentEntryDbId = null;

        var day = EntryDate.Date;
        var userId = UserSession.CurrentUserId!.Value;

        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

        if (existing == null)
        {
            Title = "";
            Content = "";
            PrimaryMoodGroup = "Neutral";

            SecondaryMoods = new();
            SelectedTags = new();

            CreatedAt = DateTime.UtcNow;
            UpdatedAt = DateTime.UtcNow;
            return;
        }

        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content ?? "";

        PrimaryMoodGroup = string.IsNullOrWhiteSpace(existing.Mood) ? "Neutral" : existing.Mood;
        if (!MoodMap.ContainsKey(PrimaryMoodGroup))
            PrimaryMoodGroup = "Neutral";

        SecondaryMoods = SplitCsv(existing.SecondaryMoodsCsv);
        SelectedTags = SplitCsv(existing.TagsCsv);

        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;
        EntryDate = existing.EntryDate.Date;

        InfoMessage = "An entry already exists for this date. Saving will update it.";
    }

    /// Loads entry data by database ID
    /// <param name="id">Entry ID to load</param>
    private async Task LoadEntryByIdAsync(int id)
    {
        ErrorMessage = "";
        InfoMessage = "";

        var userId = UserSession.CurrentUserId!.Value;

        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == id);

        if (existing == null)
        {
            ErrorMessage = "Entry not found.";
            return;
        }

        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content ?? "";

        PrimaryMoodGroup = string.IsNullOrWhiteSpace(existing.Mood) ? "Neutral" : existing.Mood;
        if (!MoodMap.ContainsKey(PrimaryMoodGroup))
            PrimaryMoodGroup = "Neutral";

        SecondaryMoods = SplitCsv(existing.SecondaryMoodsCsv);
        SelectedTags = SplitCsv(existing.TagsCsv);

        EntryDate = existing.EntryDate.Date;
        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;

        InfoMessage = "Editing an existing entry.";
    }

    /// Saves the current entry (creates new or updates existing)
    private async Task SaveEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";

        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            ErrorMessage = "You must be logged in to save an entry.";
            Nav.NavigateTo("/login");
            return;
        }

        if (string.IsNullOrWhiteSpace(Title))
        {
            ErrorMessage = "Title is required.";
            return;
        }

        if (string.IsNullOrWhiteSpace(StripHtml(Content)))
        {
            ErrorMessage = "Content is required.";
            return;
        }

        IsSaving = true;

        try
        {
            var userId = UserSession.CurrentUserId.Value;
            var day = EntryDate.Date;

            if (CurrentEntryDbId.HasValue)
            {
                var existing = await DB.JournalEntries
                    .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

                if (existing == null)
                {
                    ErrorMessage = "Entry not found (maybe deleted).";
                    return;
                }

                existing.Title = Title.Trim();
                existing.Content = Content;
                existing.Mood = PrimaryMoodGroup;
                existing.EntryDate = day;

                existing.SecondaryMoodsCsv = string.Join(",", SecondaryMoods);
                existing.TagsCsv = string.Join(",", SelectedTags);

                existing.UpdatedAt = DateTime.UtcNow;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            var existingForDay = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

            if (existingForDay != null)
            {
                existingForDay.Title = Title.Trim();
                existingForDay.Content = Content;
                existingForDay.Mood = PrimaryMoodGroup;

                existingForDay.SecondaryMoodsCsv = string.Join(",", SecondaryMoods);
                existingForDay.TagsCsv = string.Join(",", SelectedTags);

                existingForDay.UpdatedAt = DateTime.UtcNow;

                CurrentEntryDbId = existingForDay.Id;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            var entry = new JournalEntry
            {
                Title = Title.Trim(),
                Content = Content,
                Mood = PrimaryMoodGroup,

                SecondaryMoodsCsv = string.Join(",", SecondaryMoods),
                TagsCsv = string.Join(",", SelectedTags),

                UserId = userId,
                EntryDate = day,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            DB.JournalEntries.Add(entry);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Save failed: " + ex.Message;
        }
        finally
        {
            IsSaving = false;
        }
    }

    /// Deletes the current entry from the database
    private async Task DeleteEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";
        ShowDeleteModal = false;

        if (!CurrentEntryDbId.HasValue) return;
        if (UserSession.CurrentUserId is null) return;

        try
        {
            var userId = UserSession.CurrentUserId.Value;

            var existing = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

            if (existing == null)
            {
                ErrorMessage = "Entry not found.";
                return;
            }

            DB.JournalEntries.Remove(existing);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Delete failed: " + ex.Message;
        }
    }
}
