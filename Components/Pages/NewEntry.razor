@page "/new-entry"
@page "/new-entry/{EntryId:int}"

@*
    NEW ENTRY PAGE
*@

@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.EntityFrameworkCore
@using Microsoft.JSInterop
@using JournalApp.Models
@using JournalApp.Components.Shared

@inject IJSRuntime JS
@inject JournalApp.Services.UserService UserSession
@inject JournalApp.Data.AppDbContext DB
@inject NavigationManager Nav

<div class="entry-container">

    <!-- Header row: Back / Page Title / Save / Delete -->
    <div class="header">
        <button type="button" class="back-link" @onclick="GoBack">← Back</button>

        <!-- Title changes depending on whether an entry is loaded from DB -->
        <h1>@(IsEditMode ? "Edit Entry" : "New Entry")</h1>

        <div class="header-actions">
            @if (IsEditMode)
            {
                <button type="button"
                        class="delete-btn"
                        @onclick="DeleteEntry"
                        disabled="@IsSaving">
                    Delete
                </button>
            }

            <button type="button"
                    class="save-btn"
                    @onclick="SaveEntry"
                    disabled="@IsSaving">
                @(IsSaving ? "Saving..." : "Save")
            </button>
        </div>
    </div>

    <!-- Info message (shown when an entry already exists for selected date) -->
    @if (!string.IsNullOrWhiteSpace(InfoMessage))
    {
        <div class="info-box">@InfoMessage</div>
    }

    <!-- System generated timestamps (read-only UI) -->
    <div class="meta-row">
        <div class="meta-item">
            <span class="meta-label">Created At</span>
            <span class="meta-value">@CreatedAt.ToLocalTime().ToString("g")</span>
        </div>

        <div class="meta-item">
            <span class="meta-label">Updated At</span>
            <span class="meta-value">@UpdatedAt.ToLocalTime().ToString("g")</span>
        </div>
    </div>

    <!-- Title -->
    <label class="sr-only">Title</label>
    <input class="title-input"
           type="text"
           placeholder="Enter title..."
           @bind="Title"
           @oninput="@(_ => TouchUpdated())" />

    <!-- Date + Category -->
    <div class="row">
        <div class="field">
            <label>Date</label>

            @* Value/ValueChanged used so we can run code when date changes *@
            <InputDate class="input"
                       Value="EntryDate"
                       ValueChanged="@(async (DateTime d) => await OnEntryDateChanged(d))"
                       ValueExpression="(() => EntryDate)" />

            <div class="hint">Only one entry is allowed per day.</div>
        </div>

        <div class="field">
            <label>Category</label>

            @* Category currently UI-only (not stored in DB) *@
            <select class="input" @bind="Category" @bind:after="TouchUpdated">
                @foreach (var c in Categories)
                {
                    <option value="@c">@c</option>
                }
            </select>
        </div>
    </div>

    @* ✅ Extracted UI: Mood selection *@
    <MoodPicker MoodGroups="MoodGroups"
                MoodMap="MoodMap"
                @bind-PrimaryMoodGroup="PrimaryMoodGroup"
                @bind-SecondaryMoods="SecondaryMoods" />

    @* ✅ Extracted UI: Tags *@
    <TagPicker PrebuiltTags="PrebuiltTags"
               @bind-SelectedTags="SelectedTags" />

    <!-- Content (Rich Text HTML) -->
    <div class="field">
        <label>Content (Rich Text)</label>

        @* ✅ Extracted UI: RichTextEditor *@
        <RichTextEditor @bind-Html="Content" Placeholder="Type a message..." />

        <div class="hint">
            Select text → Bold/Italic/Link. Lists/Heading apply at cursor.
        </div>
    </div>

    <!-- Error message -->
    @if (!string.IsNullOrWhiteSpace(ErrorMessage))
    {
        <div class="error-box">@ErrorMessage</div>
    }
</div>

@code {
    // -------------------------
    // Routing / Mode
    // -------------------------

    // /new-entry/{EntryId:int} will populate this parameter
    [Parameter] public int? EntryId { get; set; }

    // True when we have an entry loaded from DB
    private bool IsEditMode => CurrentEntryDbId.HasValue;

    // DB Id of current entry being edited; null = create mode
    private int? CurrentEntryDbId { get; set; } = null;

    // -------------------------
    // Fields (stored + UI-only)
    // -------------------------

    private string Title { get; set; } = "";
    private DateTime EntryDate { get; set; } = DateTime.Today;
    private string Category { get; set; } = "Personal"; // UI-only right now

    // Rich HTML content saved to DB
    private string Content { get; set; } = "";

    // System timestamps saved to DB
    private DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    private DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Mood data
    private readonly List<string> MoodGroups = new() { "Positive", "Neutral", "Negative" };

    private readonly Dictionary<string, List<string>> MoodMap = new()
    {
        ["Positive"] = new() { "Happy", "Excited", "Relaxed", "Grateful", "Confident" },
        ["Neutral"]  = new() { "Calm", "Thoughtful", "Curious", "Nostalgic", "Bored" },
        ["Negative"] = new() { "Sad", "Angry", "Stressed", "Lonely", "Anxious" }
    };

    // Stored in DB as JournalEntry.Mood (analytics)
    private string PrimaryMoodGroup { get; set; } = "Neutral";

    // UI-only (not stored)
    private List<string> SecondaryMoods { get; set; } = new();

    // Categories (UI-only)
    private readonly List<string> Categories = new()
    {
        "Personal", "Work", "Studies", "Family", "Friends", "Health", "Self-care", "Travel", "Finance"
    };

    // Tags (UI-only)
    private readonly List<string> PrebuiltTags = new()
    {
        "Work","Career","Studies","Family","Friends","Relationships","Health","Fitness","Personal Growth","Self-care",
        "Hobbies","Travel","Nature","Finance","Spirituality","Birthday","Holiday","Vacation","Celebration","Exercise",
        "Reading","Writing","Cooking","Meditation","Yoga","Music","Shopping","Parenting","Projects","Planning","Reflection"
    };

    private List<string> SelectedTags { get; set; } = new();

    // UI state
    private bool IsSaving { get; set; } = false;
    private string ErrorMessage { get; set; } = "";
    private string InfoMessage { get; set; } = "";

    // -------------------------
    // Helpers
    // -------------------------

    /// <summary>
    /// Strip HTML tags to validate that the user typed real text.
    /// Prevents saving empty content like "<br>".
    /// </summary>
    private string StripHtml(string html)
    {
        if (string.IsNullOrWhiteSpace(html)) return "";

        var noTags = System.Text.RegularExpressions.Regex.Replace(html, "<.*?>", string.Empty);
        return System.Net.WebUtility.HtmlDecode(noTags).Trim();
    }

    /// <summary>
    /// Updates the UI-only UpdatedAt label when user edits.
    /// </summary>
    private void TouchUpdated()
    {
        UpdatedAt = DateTime.UtcNow;
    }

    // -------------------------
    // Lifecycle
    // -------------------------

    protected override async Task OnInitializedAsync()
    {
        // Must be logged in
        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            Nav.NavigateTo("/login");
            return;
        }

        // If opened by id: load that entry
        if (EntryId.HasValue)
        {
            await LoadEntryByIdAsync(EntryId.Value);
            return;
        }

        // Otherwise: load today's entry if exists (or create mode)
        await LoadEntryForDateAsync();
    }

    // -------------------------
    // Navigation + Date loading
    // -------------------------

    private void GoBack()
    {
        Nav.NavigateTo("/dashboard");
    }

    private async Task OnEntryDateChanged(DateTime newDate)
    {
        EntryDate = newDate.Date;
        await LoadEntryForDateAsync();
    }

    /// <summary>
    /// Loads entry for EntryDate for the current user.
    /// If entry exists -> edit mode; else -> create mode.
    /// </summary>
    private async Task LoadEntryForDateAsync()
    {
        ErrorMessage = "";
        InfoMessage = "";
        CurrentEntryDbId = null;

        var day = EntryDate.Date;
        var userId = UserSession.CurrentUserId!.Value;

        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

        if (existing == null)
        {
            // Create mode defaults
            Title = "";
            Content = "";
            PrimaryMoodGroup = "Neutral";

            CreatedAt = DateTime.UtcNow;
            UpdatedAt = DateTime.UtcNow;

            return;
        }

        // Edit mode
        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content ?? "";

        PrimaryMoodGroup = string.IsNullOrWhiteSpace(existing.Mood) ? "Neutral" : existing.Mood;
        if (!MoodMap.ContainsKey(PrimaryMoodGroup))
            PrimaryMoodGroup = "Neutral";

        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;
        EntryDate = existing.EntryDate.Date;

        InfoMessage = "An entry already exists for this date. Saving will update it.";
    }

    /// <summary>
    /// Loads entry by DB Id (route: /new-entry/{EntryId})
    /// </summary>
    private async Task LoadEntryByIdAsync(int id)
    {
        ErrorMessage = "";
        InfoMessage = "";

        var userId = UserSession.CurrentUserId!.Value;

        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == id);

        if (existing == null)
        {
            ErrorMessage = "Entry not found.";
            return;
        }

        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content ?? "";

        PrimaryMoodGroup = string.IsNullOrWhiteSpace(existing.Mood) ? "Neutral" : existing.Mood;
        if (!MoodMap.ContainsKey(PrimaryMoodGroup))
            PrimaryMoodGroup = "Neutral";

        EntryDate = existing.EntryDate.Date;
        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;

        InfoMessage = "Editing an existing entry.";
    }

    // -------------------------
    // Save / Delete
    // -------------------------

    private async Task SaveEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";

        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            ErrorMessage = "You must be logged in to save an entry.";
            Nav.NavigateTo("/login");
            return;
        }

        // Validation
        if (string.IsNullOrWhiteSpace(Title))
        {
            ErrorMessage = "Title is required.";
            return;
        }

        if (string.IsNullOrWhiteSpace(StripHtml(Content)))
        {
            ErrorMessage = "Content is required.";
            return;
        }

        IsSaving = true;

        try
        {
            var userId = UserSession.CurrentUserId.Value;
            var day = EntryDate.Date;

            // EDIT: update existing by id
            if (CurrentEntryDbId.HasValue)
            {
                var existing = await DB.JournalEntries
                    .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

                if (existing == null)
                {
                    ErrorMessage = "Entry not found (maybe deleted).";
                    return;
                }

                existing.Title = Title.Trim();
                existing.Content = Content;
                existing.Mood = PrimaryMoodGroup;
                existing.EntryDate = day;
                existing.UpdatedAt = DateTime.UtcNow;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            // CREATE: enforce one-per-day
            var existingForDay = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

            if (existingForDay != null)
            {
                // If already exists for day, update instead of creating
                existingForDay.Title = Title.Trim();
                existingForDay.Content = Content;
                existingForDay.Mood = PrimaryMoodGroup;
                existingForDay.UpdatedAt = DateTime.UtcNow;

                CurrentEntryDbId = existingForDay.Id;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            // Create new entry
            var entry = new JournalEntry
            {
                Title = Title.Trim(),
                Content = Content,
                Mood = PrimaryMoodGroup,
                UserId = userId,
                EntryDate = day,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            DB.JournalEntries.Add(entry);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Save failed: " + ex.Message;
        }
        finally
        {
            IsSaving = false;
        }
    }

    private async Task DeleteEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";

        if (!CurrentEntryDbId.HasValue) return;
        if (UserSession.CurrentUserId is null) return;

        // JS confirm dialog
        var ok = await JS.InvokeAsync<bool>("confirm", "Delete this entry?");
        if (!ok) return;

        try
        {
            var userId = UserSession.CurrentUserId.Value;

            var existing = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

            if (existing == null)
            {
                ErrorMessage = "Entry not found.";
                return;
            }

            DB.JournalEntries.Remove(existing);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Delete failed: " + ex.Message;
        }
    }
}
