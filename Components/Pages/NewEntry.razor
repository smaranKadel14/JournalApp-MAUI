@page "/new-entry"
@page "/new-entry/{EntryId:int}"

@* New Entry page (Create + Update + Delete)
   - Only ONE entry per day per user
   - CreatedAt/UpdatedAt are system generated
   - When user changes date, we load that day's entry if it exists
   - Content is saved as HTML from a Teams-like Rich Text editor *@

@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.EntityFrameworkCore
@using JournalApp.Models
@using Microsoft.JSInterop

@inject IJSRuntime JS
@inject JournalApp.Services.UserService UserSession
@inject JournalApp.Data.AppDbContext DB
@inject NavigationManager Nav

<div class="entry-container">

    <!-- Header row: Back / Title / Save / Delete -->
    <div class="header">
        <button type="button" class="back-link" @onclick="GoBack">← Back</button>

        <h1>@(IsEditMode ? "Edit Entry" : "New Entry")</h1>

        <div style="display:flex; gap:10px; align-items:center;">
            @* Show Delete only when we are editing an existing entry *@
            @if (IsEditMode)
            {
                <button type="button" class="delete-btn" @onclick="DeleteEntry" disabled="@IsSaving">
                    Delete
                </button>
            }

            <button type="button" class="save-btn" @onclick="SaveEntry" disabled="@IsSaving">
                @(IsSaving ? "Saving..." : "Save")
            </button>
        </div>
    </div>

    <!-- Info message (when entry exists for selected date) -->
    @if (!string.IsNullOrWhiteSpace(InfoMessage))
    {
        <div class="info-box">@InfoMessage</div>
    }

    <!-- System generated timestamps (read-only) -->
    <div class="meta-row">
        <div class="meta-item">
            <span class="meta-label">Created At</span>
            <span class="meta-value">@CreatedAt.ToLocalTime().ToString("g")</span>
        </div>
        <div class="meta-item">
            <span class="meta-label">Updated At</span>
            <span class="meta-value">@UpdatedAt.ToLocalTime().ToString("g")</span>
        </div>
    </div>

    <!-- Title -->
    <label class="sr-only">Title</label>
    <input class="title-input" type="text" placeholder="Enter title..." @bind="Title" />

    <!-- Date + Category row -->
    <div class="row">
        <div class="field">
            <label>Date</label>

            @* IMPORTANT:
               We use Value/ValueChanged so we can "react" to date changes cleanly *@
            <InputDate class="input"
                       Value="EntryDate"
                       ValueChanged="@(async (DateTime d) => await OnEntryDateChanged(d))"
                       ValueExpression="(() => EntryDate)" />

            <div class="hint">Only one entry is allowed per day.</div>
        </div>

        <div class="field">
            <label>Category</label>
            <select class="input" @bind="Category">
                @foreach (var c in Categories)
                {
                    <option value="@c">@c</option>
                }
            </select>
        </div>
    </div>

    <!-- Primary Mood (required) -->
    <div class="field">
        <label>Primary Mood (required)</label>

        <!-- Choose mood group -->
        <div class="mood-selector">
            @foreach (var group in MoodGroups)
            {
                <button type="button"
                        class="mood-opt @(PrimaryMoodGroup == group ? "selected" : "")"
                        @onclick="@(() => SetPrimaryGroup(group))">
                    @group
                </button>
            }
        </div>

        <div class="hint">
            Your primary mood group is stored in DB as <b>Mood</b> (for analytics).
        </div>
    </div>

    <!-- Secondary Moods (optional, max 2) -->
    <div class="field">
        <label>Secondary Mood (optional, max 2)</label>

        @foreach (var group in MoodGroups)
        {
            <div class="secondary-group">
                <div class="secondary-title">@group</div>

                <div class="mood-categories">
                    @foreach (var mood in MoodMap[group])
                    {
                        var isSelected = SecondaryMoods.Contains(mood);

                        <button type="button"
                                class="pill @(isSelected ? "selected" : "")"
                                @onclick="@(() => ToggleSecondaryMood(mood))">
                            @mood
                        </button>
                    }
                </div>
            </div>
        }

        <div class="hint">
            Secondary moods are UI-only for now (we can add DB columns later).
        </div>
    </div>

    <!-- Tags (pre-built + custom) -->
    <div class="field">
        <label>Tags (optional)</label>

        <div class="tag-cloud">
            @foreach (var tag in PrebuiltTags)
            {
                var selected = SelectedTags.Contains(tag);

                <button type="button"
                        class="tag-btn @(selected ? "selected" : "")"
                        @onclick="@(() => ToggleTag(tag))">
                    @tag
                </button>
            }
        </div>

        <div class="tag-add">
            <input class="input"
                   type="text"
                   placeholder="Add a custom tag and press Enter..."
                   @bind="CustomTag"
                   @onkeydown="OnCustomTagKeyDown" />

            <button type="button" class="tag-add-btn" @onclick="AddCustomTag">
                Add
            </button>
        </div>

        @if (SelectedTags.Count > 0)
        {
            <div class="selected-tags">
                @foreach (var t in SelectedTags)
                {
                    <span class="selected-tag">
                        @t
                        <button type="button" class="tag-remove" @onclick="@(() => RemoveTag(t))">×</button>
                    </span>
                }
            </div>
        }
    </div>

    <!-- Rich Text Content (Teams-like) -->
    <div class="field">
        <label>Content (Rich Text)</label>

        <!-- Toolbar -->
        <div class="rte-toolbar">
            <button type="button" class="rte-btn" title="Bold" @onclick="BoldAsync"><b>B</b></button>
            <button type="button" class="rte-btn" title="Italic" @onclick="ItalicAsync"><i>I</i></button>
            <button type="button" class="rte-btn" title="Strikethrough" @onclick="StrikeAsync"><s>S</s></button>

            <div class="rte-sep"></div>

            <button type="button" class="rte-btn" title="Heading" @onclick="H2Async">H</button>
            <button type="button" class="rte-btn" title="Bullet List" @onclick="BulletsAsync">•≡</button>
            <button type="button" class="rte-btn" title="Numbered List" @onclick="NumbersAsync">1≡</button>

            <div class="rte-sep"></div>

            <button type="button" class="rte-btn" title="Insert Link" @onclick="LinkAsync">🔗</button>
            <button type="button" class="rte-btn" title="Remove Link" @onclick="UnlinkAsync">⛓️‍💥</button>
        </div>

        <!-- Editor surface -->
        <div id="@EditorDomId"
             class="rte-editor"
             contenteditable="true"
             data-placeholder="Type a message..."
             @ref="EditorRef">
        </div>

        <div class="hint">
            Tip: select text → click toolbar (Bold/Italic/Link). Lists/Heading apply at cursor.
        </div>
    </div>

    <!-- Error message -->
    @if (!string.IsNullOrWhiteSpace(ErrorMessage))
    {
        <div class="error-box">@ErrorMessage</div>
    }
</div>

@code {
    // -------------------------
    // Routing / mode
    // -------------------------

    // Route param: /new-entry/5 means edit entry Id=5
    [Parameter] public int? EntryId { get; set; }

    // We are in "edit mode" if we loaded an entry from DB
    private bool IsEditMode => CurrentEntryDbId.HasValue;

    // Holds DB Id of currently loaded entry (if any)
    private int? CurrentEntryDbId { get; set; } = null;

    // -------------------------
    // Fields
    // -------------------------

    // Basic fields
    private string Title { get; set; } = "";
    private DateTime EntryDate { get; set; } = DateTime.Today;
    private string Category { get; set; } = "Personal";

    // IMPORTANT: Content is HTML from the rich text editor
    private string Content { get; set; } = "";

    // System timestamps (stored in DB)
    private DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    private DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Mood data
    private readonly List<string> MoodGroups = new() { "Positive", "Neutral", "Negative" };

    private readonly Dictionary<string, List<string>> MoodMap = new()
    {
        ["Positive"] = new() { "Happy", "Excited", "Relaxed", "Grateful", "Confident" },
        ["Neutral"]  = new() { "Calm", "Thoughtful", "Curious", "Nostalgic", "Bored" },
        ["Negative"] = new() { "Sad", "Angry", "Stressed", "Lonely", "Anxious" }
    };

    // Primary mood group (stored in DB)
    private string PrimaryMoodGroup { get; set; } = "Neutral";

    // Secondary moods (UI-only for now)
    private List<string> SecondaryMoods { get; set; } = new();

    // Category list
    private readonly List<string> Categories = new()
    {
        "Personal", "Work", "Studies", "Family", "Friends", "Health", "Self-care", "Travel", "Finance"
    };

    // Tags list (UI-only for now)
    private readonly List<string> PrebuiltTags = new()
    {
        "Work","Career","Studies","Family","Friends","Relationships","Health","Fitness","Personal Growth","Self-care",
        "Hobbies","Travel","Nature","Finance","Spirituality","Birthday","Holiday","Vacation","Celebration","Exercise",
        "Reading","Writing","Cooking","Meditation","Yoga","Music","Shopping","Parenting","Projects","Planning","Reflection"
    };

    private List<string> SelectedTags { get; set; } = new();
    private string CustomTag { get; set; } = "";

    // UI helpers
    private bool IsSaving { get; set; } = false;
    private string ErrorMessage { get; set; } = "";
    private string InfoMessage { get; set; } = "";

    // -------------------------
    // Rich Text Editor wiring
    // -------------------------

    // DOM id used by JS to get/set editor HTML
    private const string EditorDomId = "journal-rte";

    // Ref to editor element (kept for future enhancements)
    private ElementReference EditorRef;

    // We queue HTML updates until the editor is rendered
    private string _pendingEditorHtml = "";
    private bool _hasPendingEditorHtml = false;

    protected override async Task OnInitializedAsync()
    {
        // Guard: must be logged in
        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            Nav.NavigateTo("/login");
            return;
        }

        // If user opened /new-entry/{id}, load by ID
        if (EntryId.HasValue)
        {
            await LoadEntryByIdAsync(EntryId.Value);
            return;
        }

        // Otherwise, load today's entry if it exists
        await LoadEntryForDateAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // After render we can safely talk to the editor via JS
        if (firstRender)
        {
            // First render: set initial content
            await JS.InvokeVoidAsync("journalRte.setHtml", EditorDomId, Content);
        }

        // If we queued editor HTML (after a DB load), apply it here
        if (_hasPendingEditorHtml)
        {
            await JS.InvokeVoidAsync("journalRte.setHtml", EditorDomId, _pendingEditorHtml);
            _hasPendingEditorHtml = false;
        }
    }

    private void QueueEditorHtml(string html)
    {
        // We cannot set editor HTML until it is rendered, so we queue it
        _pendingEditorHtml = html ?? "";
        _hasPendingEditorHtml = true;
    }

    private async Task SyncEditorToContentAsync()
    {
        // Pull latest HTML from the editor before saving
        Content = await JS.InvokeAsync<string>("journalRte.getHtml", EditorDomId) ?? "";
    }

    private string StripHtml(string html)
    {
        // Used only for validation so empty rich text doesn't pass
        if (string.IsNullOrWhiteSpace(html)) return "";
        return System.Text.RegularExpressions.Regex.Replace(html, "<.*?>", string.Empty).Trim();
    }

    // Run formatting commands (Teams-like toolbar)
    private async Task CmdAsync(string cmd, string? value = null)
    {
        // Keep focus in editor so commands apply correctly
        await JS.InvokeVoidAsync("journalRte.focus", EditorDomId);
        await JS.InvokeVoidAsync("journalRte.exec", cmd, value);
    }

    private Task BoldAsync() => CmdAsync("bold");
    private Task ItalicAsync() => CmdAsync("italic");
    private Task StrikeAsync() => CmdAsync("strikeThrough");
    private Task BulletsAsync() => CmdAsync("insertUnorderedList");
    private Task NumbersAsync() => CmdAsync("insertOrderedList");
    private Task H2Async() => CmdAsync("formatBlock", "h2");
    private Task UnlinkAsync() => CmdAsync("unlink");

    private async Task LinkAsync()
    {
        // Simple link workflow: select text -> insert link -> prompt for url
        var url = await JS.InvokeAsync<string>("prompt", "Enter URL (https://...):", "https://");
        if (string.IsNullOrWhiteSpace(url)) return;

        await CmdAsync("createLink", url.Trim());
    }

    // -------------------------
    // Navigation + date loading
    // -------------------------

    private void GoBack()
    {
        // Go back to dashboard
        Nav.NavigateTo("/dashboard");
    }

    private async Task OnEntryDateChanged(DateTime newDate)
    {
        // Normalize date to date-only, then load entry for that day
        EntryDate = newDate.Date;
        await LoadEntryForDateAsync();
    }

    private async Task LoadEntryForDateAsync()
    {
        // Reset messages
        ErrorMessage = "";
        InfoMessage = "";
        CurrentEntryDbId = null;

        // Normalize date to date-only
        var day = EntryDate.Date;
        EntryDate = day;

        var userId = UserSession.CurrentUserId!.Value;

        // Find an existing entry for this user + this day
        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

        if (existing == null)
        {
            // Create mode: clear fields
            Title = "";
            Content = "";
            PrimaryMoodGroup = "Neutral";
            CreatedAt = DateTime.UtcNow;
            UpdatedAt = DateTime.UtcNow;

            // Push cleared content into editor UI
            QueueEditorHtml(Content);
            StateHasChanged();
            return;
        }

        // Edit mode: load fields from DB
        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content ?? "";
        PrimaryMoodGroup = string.IsNullOrWhiteSpace(existing.Mood) ? "Neutral" : existing.Mood;
        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;
        EntryDate = existing.EntryDate;

        InfoMessage = "An entry already exists for this date. Saving will update it.";

        // Push loaded content into editor UI
        QueueEditorHtml(Content);
        StateHasChanged();
    }

    private async Task LoadEntryByIdAsync(int id)
    {
        ErrorMessage = "";
        InfoMessage = "";

        var userId = UserSession.CurrentUserId!.Value;

        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == id);

        if (existing == null)
        {
            ErrorMessage = "Entry not found.";
            return;
        }

        // Load into edit mode
        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content ?? "";
        PrimaryMoodGroup = string.IsNullOrWhiteSpace(existing.Mood) ? "Neutral" : existing.Mood;
        EntryDate = existing.EntryDate;
        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;

        InfoMessage = "Editing an existing entry.";

        // Push loaded content into editor UI
        QueueEditorHtml(Content);
        StateHasChanged();
    }

    // -------------------------
    // Mood / tags helpers
    // -------------------------

    private void SetPrimaryGroup(string group)
    {
        // Switching group updates the stored mood group value
        PrimaryMoodGroup = group;
        UpdatedAt = DateTime.UtcNow;
    }

    private void ToggleSecondaryMood(string mood)
    {
        // Enforce max 2 (UI-only feature)
        if (SecondaryMoods.Contains(mood))
            SecondaryMoods.Remove(mood);
        else
        {
            if (SecondaryMoods.Count >= 2) return;
            SecondaryMoods.Add(mood);
        }

        UpdatedAt = DateTime.UtcNow;
    }

    private void ToggleTag(string tag)
    {
        if (SelectedTags.Contains(tag))
            SelectedTags.Remove(tag);
        else
            SelectedTags.Add(tag);

        UpdatedAt = DateTime.UtcNow;
    }

    private void RemoveTag(string tag)
    {
        SelectedTags.Remove(tag);
        UpdatedAt = DateTime.UtcNow;
    }

    private void AddCustomTag()
    {
        var tag = (CustomTag ?? "").Trim();
        if (string.IsNullOrWhiteSpace(tag)) return;

        // Avoid duplicates (case-insensitive)
        if (!SelectedTags.Any(t => t.Equals(tag, StringComparison.OrdinalIgnoreCase)))
            SelectedTags.Add(tag);

        CustomTag = "";
        UpdatedAt = DateTime.UtcNow;
    }

    private void OnCustomTagKeyDown(KeyboardEventArgs e)
    {
        // Enter adds the custom tag quickly
        if (e.Key == "Enter")
            AddCustomTag();
    }

    // -------------------------
    // Save / Delete (CRUD)
    // -------------------------

    private async Task SaveEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";

        // Must be logged in
        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            ErrorMessage = "You must be logged in to save an entry.";
            Nav.NavigateTo("/login");
            return;
        }

        // Pull latest HTML from rich editor before validation/save
        await SyncEditorToContentAsync();

        // Basic validation
        if (string.IsNullOrWhiteSpace(Title))
        {
            ErrorMessage = "Title is required.";
            return;
        }

        // Validate using plain text (strip HTML)
        if (string.IsNullOrWhiteSpace(StripHtml(Content)))
        {
            ErrorMessage = "Content is required.";
            return;
        }

        IsSaving = true;

        try
        {
            var userId = UserSession.CurrentUserId.Value;
            var day = EntryDate.Date;

            // If editing, update that entry
            if (CurrentEntryDbId.HasValue)
            {
                var existing = await DB.JournalEntries
                    .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

                if (existing == null)
                {
                    ErrorMessage = "Entry not found (maybe deleted).";
                    return;
                }

                // Update fields
                existing.Title = Title.Trim();
                existing.Content = Content;
                existing.Mood = PrimaryMoodGroup;
                existing.EntryDate = day;

                // System update timestamp
                existing.UpdatedAt = DateTime.UtcNow;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            // Enforce: only one entry per day
            var existingForDay = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

            if (existingForDay != null)
            {
                // Convert create into update (safe fallback)
                existingForDay.Title = Title.Trim();
                existingForDay.Content = Content;
                existingForDay.Mood = PrimaryMoodGroup;
                existingForDay.UpdatedAt = DateTime.UtcNow;

                CurrentEntryDbId = existingForDay.Id;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            // Create new entry
            var entry = new JournalEntry
            {
                Title = Title.Trim(),
                Content = Content,
                Mood = PrimaryMoodGroup,
                UserId = userId,

                // Daily date + system timestamps
                EntryDate = day,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            DB.JournalEntries.Add(entry);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Save failed: " + ex.Message;
        }
        finally
        {
            IsSaving = false;
        }
    }

    private async Task DeleteEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";

        // Only allow delete in edit mode
        if (!CurrentEntryDbId.HasValue) return;
        if (UserSession.CurrentUserId is null) return;

        // Confirm delete (prevents accidental deletion)
        var ok = await JS.InvokeAsync<bool>("confirm", "Delete this entry?");
        if (!ok) return;

        try
        {
            var userId = UserSession.CurrentUserId.Value;

            // Find and remove
            var existing = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

            if (existing == null)
            {
                ErrorMessage = "Entry not found.";
                return;
            }

            DB.JournalEntries.Remove(existing);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Delete failed: " + ex.Message;
        }
    }
}
