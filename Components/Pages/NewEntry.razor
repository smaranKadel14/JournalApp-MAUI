@page "/new-entry"
@page "/new-entry/{EntryId:int}"

@* New Entry page (Create + Update + Delete)
   - Only ONE entry per day per user
   - CreatedAt/UpdatedAt are system generated
   - When user changes date, we load that day's entry if it exists
   - Content is saved as HTML from a Rich Text editor *@

@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.EntityFrameworkCore
@using Microsoft.JSInterop
@using JournalApp.Models

@inject IJSRuntime JS
@inject JournalApp.Services.UserService UserSession
@inject JournalApp.Data.AppDbContext DB
@inject NavigationManager Nav

<div class="entry-container">

    <!-- Header row: Back / Title / Save / Delete -->
    <div class="header">
        <button type="button" class="back-link" @onclick="GoBack">← Back</button>

        <h1>@(IsEditMode ? "Edit Entry" : "New Entry")</h1>

        <div style="display:flex; gap:10px; align-items:center;">
            @if (IsEditMode)
            {
                <button type="button" class="delete-btn" @onclick="DeleteEntry" disabled="@IsSaving">
                    Delete
                </button>
            }

            <button type="button" class="save-btn" @onclick="SaveEntry" disabled="@IsSaving">
                @(IsSaving ? "Saving..." : "Save")
            </button>
        </div>
    </div>

    <!-- Info message (when entry exists for selected date) -->
    @if (!string.IsNullOrWhiteSpace(InfoMessage))
    {
        <div class="info-box">@InfoMessage</div>
    }

    <!-- System generated timestamps (read-only) -->
    <div class="meta-row">
        <div class="meta-item">
            <span class="meta-label">Created At</span>
            <span class="meta-value">@CreatedAt.ToLocalTime().ToString("g")</span>
        </div>
        <div class="meta-item">
            <span class="meta-label">Updated At</span>
            <span class="meta-value">@UpdatedAt.ToLocalTime().ToString("g")</span>
        </div>
    </div>

    <!-- Title -->
    <label class="sr-only">Title</label>
    <input class="title-input" type="text" placeholder="Enter title..." @bind="Title" />

    <!-- Date + Category row -->
    <div class="row">
        <div class="field">
            <label>Date</label>

            @* Value/ValueChanged so we can react to date changes *@
            <InputDate class="input"
                       Value="EntryDate"
                       ValueChanged="@(async (DateTime d) => await OnEntryDateChanged(d))"
                       ValueExpression="(() => EntryDate)" />

            <div class="hint">Only one entry is allowed per day.</div>
        </div>

        <div class="field">
            <label>Category</label>
            <select class="input" @bind="Category">
                @foreach (var c in Categories)
                {
                    <option value="@c">@c</option>
                }
            </select>
        </div>
    </div>

    <!-- Primary Mood -->
    <div class="field">
        <label>Primary Mood (required)</label>

        <div class="mood-selector">
            @foreach (var group in MoodGroups)
            {
                <button type="button"
                        class="mood-opt @(PrimaryMoodGroup == group ? "selected" : "")"
                        @onclick="@(() => SetPrimaryGroup(group))">
                    @group
                </button>
            }
        </div>

        <div class="hint">
            Your primary mood group is stored in DB as <b>Mood</b> (for analytics).
        </div>
    </div>

    <!-- Secondary Moods (optional) -->
    <div class="field">
        <label>Secondary Mood (optional, max 2)</label>

        @foreach (var group in MoodGroups)
        {
            <div class="secondary-group">
                <div class="secondary-title">@group</div>

                <div class="mood-categories">
                    @foreach (var mood in MoodMap[group])
                    {
                        var isSelected = SecondaryMoods.Contains(mood);

                        <button type="button"
                                class="pill @(isSelected ? "selected" : "")"
                                @onclick="@(() => ToggleSecondaryMood(mood))">
                            @mood
                        </button>
                    }
                </div>
            </div>
        }

        <div class="hint">
            Secondary moods are UI-only for now (we can add DB columns later).
        </div>
    </div>

    <!-- Tags (pre-built + custom) -->
    <div class="field">
        <label>Tags (optional)</label>

        <div class="tag-cloud">
            @foreach (var tag in PrebuiltTags)
            {
                var selected = SelectedTags.Contains(tag);

                <button type="button"
                        class="tag-btn @(selected ? "selected" : "")"
                        @onclick="@(() => ToggleTag(tag))">
                    @tag
                </button>
            }
        </div>

        <div class="tag-add">
            <input class="input"
                   type="text"
                   placeholder="Add a custom tag and press Enter..."
                   @bind="CustomTag"
                   @onkeydown="OnCustomTagKeyDown" />

            <button type="button" class="tag-add-btn" @onclick="AddCustomTag">
                Add
            </button>
        </div>

        @if (SelectedTags.Count > 0)
        {
            <div class="selected-tags">
                @foreach (var t in SelectedTags)
                {
                    <span class="selected-tag">
                        @t
                        <button type="button" class="tag-remove" @onclick="@(() => RemoveTag(t))">×</button>
                    </span>
                }
            </div>
        }
    </div>

    <!-- Rich Text Content -->
    <div class="field">
        <label>Content (Rich Text)</label>

        <!-- Toolbar -->
        <div class="rte-toolbar" role="toolbar" aria-label="Formatting toolbar">
            <button type="button" class="rte-btn" title="Bold" @onclick="BoldAsync"><b>B</b></button>
            <button type="button" class="rte-btn" title="Italic" @onclick="ItalicAsync"><i>I</i></button>
            <button type="button" class="rte-btn" title="Strikethrough" @onclick="StrikeAsync"><s>S</s></button>

            <span class="rte-sep" aria-hidden="true"></span>

            <button type="button" class="rte-btn" title="Heading" @onclick="H2Async">H</button>
            <button type="button" class="rte-btn" title="Bullet list" @onclick="BulletsAsync">•≡</button>
            <button type="button" class="rte-btn" title="Numbered list" @onclick="NumbersAsync">1≡</button>

            <span class="rte-sep" aria-hidden="true"></span>

            <button type="button" class="rte-btn" title="Insert link" @onclick="LinkAsync">🔗</button>
            <button type="button" class="rte-btn" title="Remove link" @onclick="UnlinkAsync">⨯</button>
        </div>

        <!-- Editor surface -->
        <div id="@EditorId"
             class="rte-editor"
             contenteditable="true"
             data-placeholder="Type a message..."
             @ref="EditorRef"
             @oninput="OnEditorInput">
        </div>

        <div class="hint">
            Select text → Bold/Italic/Link. Lists/Heading apply at cursor.
        </div>
    </div>

    <!-- Error message -->
    @if (!string.IsNullOrWhiteSpace(ErrorMessage))
    {
        <div class="error-box">@ErrorMessage</div>
    }
</div>

@code {
    // -------------------------
    // Routing / mode
    // -------------------------

    [Parameter] public int? EntryId { get; set; }                 // /new-entry/5 => open entry id 5
    private bool IsEditMode => CurrentEntryDbId.HasValue;         // Edit mode if a DB entry is loaded
    private int? CurrentEntryDbId { get; set; } = null;           // Current DB Id (null means "new")

    // -------------------------
    // Fields
    // -------------------------

    private string Title { get; set; } = "";
    private DateTime EntryDate { get; set; } = DateTime.Today;
    private string Category { get; set; } = "Personal";

    // Rich editor stores HTML here (saved to DB)
    private string Content { get; set; } = "";

    // System timestamps (stored in DB)
    private DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    private DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Mood data
    private readonly List<string> MoodGroups = new() { "Positive", "Neutral", "Negative" };

    private readonly Dictionary<string, List<string>> MoodMap = new()
    {
        ["Positive"] = new() { "Happy", "Excited", "Relaxed", "Grateful", "Confident" },
        ["Neutral"] = new() { "Calm", "Thoughtful", "Curious", "Nostalgic", "Bored" },
        ["Negative"] = new() { "Sad", "Angry", "Stressed", "Lonely", "Anxious" }
    };

    // Stored in DB (analytics)
    private string PrimaryMoodGroup { get; set; } = "Neutral";

    // UI helper (used for safe defaults)
    private string PrimaryMood { get; set; } = "Calm";

    // UI-only
    private List<string> SecondaryMoods { get; set; } = new();

    // Category list
    private readonly List<string> Categories = new()
    {
        "Personal", "Work", "Studies", "Family", "Friends", "Health", "Self-care", "Travel", "Finance"
    };

    // Tags list
    private readonly List<string> PrebuiltTags = new()
    {
        "Work","Career","Studies","Family","Friends","Relationships","Health","Fitness","Personal Growth","Self-care",
        "Hobbies","Travel","Nature","Finance","Spirituality","Birthday","Holiday","Vacation","Celebration","Exercise",
        "Reading","Writing","Cooking","Meditation","Yoga","Music","Shopping","Parenting","Projects","Planning","Reflection"
    };

    private List<string> SelectedTags { get; set; } = new();
    private string CustomTag { get; set; } = "";

    // UI state
    private bool IsSaving { get; set; } = false;
    private string ErrorMessage { get; set; } = "";
    private string InfoMessage { get; set; } = "";

    // -------------------------
    // Rich Text Editor wiring
    // -------------------------

    private string EditorId { get; } = $"rte_{Guid.NewGuid():N}";  // Unique editor id so JS targets correct element
    private ElementReference EditorRef;                             // Reference to the div (future use)

    private bool _rteInitialized = false;                           // True after first render (safe to call JS)
    private string _pendingEditorHtml = "";                         // Queued HTML to apply into editor
    private bool _applyPendingEditorHtml = false;                   // Flag: apply queued HTML on render

    // Prevent overlapping JS calls while typing fast (keeps UI stable)
    private bool _editorSyncInProgress = false;

    /// <summary>
    /// Queue HTML to be applied into editor after Blazor renders.
    /// Use when loading a date / clearing / opening by id.
    /// </summary>
    private void QueueEditorHtml(string html)
    {
        _pendingEditorHtml = html ?? "";
        _applyPendingEditorHtml = true;
    }

    /// <summary>
    /// Strip HTML tags to validate "real" text (prevents saving empty like "<br>").
    /// </summary>
    private string StripHtml(string html)
    {
        if (string.IsNullOrWhiteSpace(html)) return "";

        var noTags = System.Text.RegularExpressions.Regex.Replace(html, "<.*?>", string.Empty);
        return System.Net.WebUtility.HtmlDecode(noTags).Trim();
    }

    /// <summary>
    /// Updates the UI-only UpdatedAt label when user edits anything.
    /// DB UpdatedAt is set on save.
    /// </summary>
    private void TouchUpdated()
    {
        UpdatedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Keep Content synced with the editor while the user types.
    /// IMPORTANT: Never let JS errors crash Blazor (otherwise buttons stop working).
    /// </summary>
    private async Task OnEditorInput()
    {
        if (!_rteInitialized) return;
        if (_editorSyncInProgress) return;

        _editorSyncInProgress = true;

        try
        {
            Content = await JS.InvokeAsync<string>("rte.getHtml", EditorId);
            TouchUpdated();
        }
        catch
        {
            // Swallow JS errors so the page doesn't become "dead"
        }
        finally
        {
            _editorSyncInProgress = false;
        }
    }

    /// <summary>
    /// Apply queued HTML into the editor safely after rendering.
    /// </summary>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
            _rteInitialized = true;

        if (_rteInitialized && _applyPendingEditorHtml)
        {
            _applyPendingEditorHtml = false;

            try
            {
                await JS.InvokeVoidAsync("rte.setHtml", EditorId, _pendingEditorHtml);
            }
            catch
            {
                // Swallow JS errors so the page stays usable
            }
        }
    }

    /// <summary>
    /// Before saving, always pull latest HTML from the editor (safe).
    /// </summary>
    private async Task SyncEditorToContentAsync()
    {
        if (!_rteInitialized) return;

        try
        {
            Content = await JS.InvokeAsync<string>("rte.getHtml", EditorId);
        }
        catch
        {
            // If JS fails, we keep the last Content we have
        }
    }

    // Toolbar actions (safe wrappers)
    private async Task SafeExecAsync(string command)
    {
        if (!_rteInitialized) return;

        try { await JS.InvokeVoidAsync("rte.exec", EditorId, command, (object?)null); }
        catch { }
    }

    private async Task SafeFormatBlockAsync(string tagName)
    {
        if (!_rteInitialized) return;

        try { await JS.InvokeVoidAsync("rte.formatBlock", EditorId, tagName); }
        catch { }
    }

    private async Task SafeCreateLinkAsync()
    {
        if (!_rteInitialized) return;

        try { await JS.InvokeVoidAsync("rte.createLinkWithPrompt", EditorId); }
        catch { }
    }

    private async Task SafeUnlinkAsync()
    {
        if (!_rteInitialized) return;

        try { await JS.InvokeVoidAsync("rte.unlink", EditorId); }
        catch { }
    }

    // Toolbar events
    private Task BoldAsync() => SafeExecAsync("bold");
    private Task ItalicAsync() => SafeExecAsync("italic");
    private Task StrikeAsync() => SafeExecAsync("strikeThrough");
    private Task BulletsAsync() => SafeExecAsync("insertUnorderedList");
    private Task NumbersAsync() => SafeExecAsync("insertOrderedList");
    private Task H2Async() => SafeFormatBlockAsync("H2");
    private Task LinkAsync() => SafeCreateLinkAsync();
    private Task UnlinkAsync() => SafeUnlinkAsync();

    // -------------------------
    // Lifecycle (initial load)
    // -------------------------

    protected override async Task OnInitializedAsync()
    {
        // Must be logged in
        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            Nav.NavigateTo("/login");
            return;
        }

        // If opened by id: load that entry
        if (EntryId.HasValue)
        {
            await LoadEntryByIdAsync(EntryId.Value);
            return;
        }

        // Otherwise: load today's entry if exists (or create mode)
        await LoadEntryForDateAsync();
    }

    // -------------------------
    // Navigation + date loading
    // -------------------------

    private void GoBack()
    {
        Nav.NavigateTo("/dashboard");
    }

    private async Task OnEntryDateChanged(DateTime newDate)
    {
        EntryDate = newDate.Date;
        await LoadEntryForDateAsync();
    }

    private async Task LoadEntryForDateAsync()
    {
        ErrorMessage = "";
        InfoMessage = "";
        CurrentEntryDbId = null;

        var day = EntryDate.Date;
        EntryDate = day;

        var userId = UserSession.CurrentUserId!.Value;

        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

        if (existing == null)
        {
            // Create mode
            Title = "";
            Content = "";

            PrimaryMoodGroup = "Neutral";
            PrimaryMood = MoodMap[PrimaryMoodGroup].First();

            CreatedAt = DateTime.UtcNow;
            UpdatedAt = DateTime.UtcNow;

            // Push cleared content into editor UI
            QueueEditorHtml(Content);
            await InvokeAsync(StateHasChanged);
            return;
        }

        // Edit mode
        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content ?? "";

        PrimaryMoodGroup = string.IsNullOrWhiteSpace(existing.Mood) ? "Neutral" : existing.Mood;
        if (!MoodMap.ContainsKey(PrimaryMoodGroup))
            PrimaryMoodGroup = "Neutral";

        PrimaryMood = MoodMap[PrimaryMoodGroup].First();

        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;
        EntryDate = existing.EntryDate.Date;

        InfoMessage = "An entry already exists for this date. Saving will update it.";

        // Push loaded content into editor UI
        QueueEditorHtml(Content);
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadEntryByIdAsync(int id)
    {
        ErrorMessage = "";
        InfoMessage = "";

        var userId = UserSession.CurrentUserId!.Value;

        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == id);

        if (existing == null)
        {
            ErrorMessage = "Entry not found.";
            return;
        }

        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content ?? "";

        PrimaryMoodGroup = string.IsNullOrWhiteSpace(existing.Mood) ? "Neutral" : existing.Mood;
        if (!MoodMap.ContainsKey(PrimaryMoodGroup))
            PrimaryMoodGroup = "Neutral";

        PrimaryMood = MoodMap[PrimaryMoodGroup].First();

        EntryDate = existing.EntryDate.Date;
        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;

        InfoMessage = "Editing an existing entry.";

        QueueEditorHtml(Content);
        await InvokeAsync(StateHasChanged);
    }

    // -------------------------
    // Mood / tags helpers
    // -------------------------

    private void SetPrimaryGroup(string group)
    {
        PrimaryMoodGroup = group;

        if (MoodMap.ContainsKey(group))
            PrimaryMood = MoodMap[group].First();

        TouchUpdated();
    }

    private void ToggleSecondaryMood(string mood)
    {
        if (SecondaryMoods.Contains(mood))
            SecondaryMoods.Remove(mood);
        else
        {
            if (SecondaryMoods.Count >= 2) return;
            SecondaryMoods.Add(mood);
        }

        TouchUpdated();
    }

    private void ToggleTag(string tag)
    {
        if (SelectedTags.Contains(tag))
            SelectedTags.Remove(tag);
        else
            SelectedTags.Add(tag);

        TouchUpdated();
    }

    private void RemoveTag(string tag)
    {
        SelectedTags.Remove(tag);
        TouchUpdated();
    }

    private void AddCustomTag()
    {
        var tag = (CustomTag ?? "").Trim();
        if (string.IsNullOrWhiteSpace(tag)) return;

        if (!SelectedTags.Any(t => t.Equals(tag, StringComparison.OrdinalIgnoreCase)))
            SelectedTags.Add(tag);

        CustomTag = "";
        TouchUpdated();
    }

    private void OnCustomTagKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
            AddCustomTag();
    }

    // -------------------------
    // Save / Delete
    // -------------------------

    private async Task SaveEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";

        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            ErrorMessage = "You must be logged in to save an entry.";
            Nav.NavigateTo("/login");
            return;
        }

        // Pull latest HTML before saving
        await SyncEditorToContentAsync();

        if (string.IsNullOrWhiteSpace(Title))
        {
            ErrorMessage = "Title is required.";
            return;
        }

        if (string.IsNullOrWhiteSpace(StripHtml(Content)))
        {
            ErrorMessage = "Content is required.";
            return;
        }

        IsSaving = true;

        try
        {
            var userId = UserSession.CurrentUserId.Value;
            var day = EntryDate.Date;

            // Update existing
            if (CurrentEntryDbId.HasValue)
            {
                var existing = await DB.JournalEntries
                    .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

                if (existing == null)
                {
                    ErrorMessage = "Entry not found (maybe deleted).";
                    return;
                }

                existing.Title = Title.Trim();
                existing.Content = Content;
                existing.Mood = PrimaryMoodGroup;
                existing.EntryDate = day;
                existing.UpdatedAt = DateTime.UtcNow;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            // Enforce one-per-day
            var existingForDay = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

            if (existingForDay != null)
            {
                existingForDay.Title = Title.Trim();
                existingForDay.Content = Content;
                existingForDay.Mood = PrimaryMoodGroup;
                existingForDay.UpdatedAt = DateTime.UtcNow;

                CurrentEntryDbId = existingForDay.Id;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            // Create new
            var entry = new JournalEntry
            {
                Title = Title.Trim(),
                Content = Content,
                Mood = PrimaryMoodGroup,
                UserId = userId,
                EntryDate = day,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            DB.JournalEntries.Add(entry);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Save failed: " + ex.Message;
        }
        finally
        {
            IsSaving = false;
        }
    }

    private async Task DeleteEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";

        if (!CurrentEntryDbId.HasValue) return;
        if (UserSession.CurrentUserId is null) return;

        var ok = await JS.InvokeAsync<bool>("confirm", "Delete this entry?");
        if (!ok) return;

        try
        {
            var userId = UserSession.CurrentUserId.Value;

            var existing = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

            if (existing == null)
            {
                ErrorMessage = "Entry not found.";
                return;
            }

            DB.JournalEntries.Remove(existing);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Delete failed: " + ex.Message;
        }
    }
}
