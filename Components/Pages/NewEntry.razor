@page "/new-entry"

@* New Entry page:
   - Collects: Title, Date, Category, Primary/Secondary moods, Tags, Markdown content
   - CreatedAt/UpdatedAt are generated by the system (read-only)
   - Saves to SQLite (currently saves Title/Content/Mood/UserId/CreatedAt) *@

@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Forms
@using JournalApp.Models
@inject JournalApp.Services.UserService UserSession
@inject JournalApp.Data.AppDbContext DB
@inject NavigationManager Nav

<div class="entry-container">

    <!-- Header row: Back / Title / Save -->
    <div class="header">
        <button type="button" class="back-link" @onclick="GoBack">← Back</button>
        <h1>New Entry</h1>
        <button type="button" class="save-btn" @onclick="SaveEntry" disabled="@IsSaving">Save</button>
    </div>

    <!-- System generated timestamps (read-only) -->
    <div class="meta-row">
        <div class="meta-item">
            <span class="meta-label">Created At</span>
            <span class="meta-value">@CreatedAt.ToLocalTime().ToString("g")</span>
        </div>
        <div class="meta-item">
            <span class="meta-label">Updated At</span>
            <span class="meta-value">@UpdatedAt.ToLocalTime().ToString("g")</span>
        </div>
    </div>

    <!-- Title -->
    <label class="sr-only">Title</label>
    <input class="title-input" type="text" placeholder="Enter title..." @bind="Title" />

    <!-- Date + Category row -->
    <div class="row">
        <div class="field">
            <label>Date</label>
            @* InputDate is safer than <input type="date"> for binding *@
            <InputDate class="input" @bind-Value="EntryDate" />
        </div>

        <div class="field">
            <label>Category</label>
            <select class="input" @bind="Category">
                @foreach (var c in Categories)
                {
                    <option value="@c">@c</option>
                }
            </select>
        </div>
    </div>

    <!-- Primary Mood (required) -->
    <div class="field">
        <label>Primary Mood (required)</label>

        <!-- Choose mood group -->
        <div class="mood-selector">
            @foreach (var group in MoodGroups)
            {
                <button type="button"
                        class="mood-opt @(PrimaryMoodGroup == group ? "selected" : "")"
                        @onclick="@(() => SetPrimaryGroup(group))">
                    @group
                </button>
            }
        </div>

        <!-- Choose mood category within the selected group -->
        <div class="mood-categories">
            @foreach (var mood in MoodMap[PrimaryMoodGroup])
            {
                <button type="button"
                        class="pill @(PrimaryMood == mood ? "selected" : "")"
                        @onclick="@(() => SetPrimaryMood(mood))">
                    @mood
                </button>
            }
        </div>

        <div class="hint">
            Pick one main mood for analytics (this is what we store as Mood in DB for now).
        </div>
    </div>

    <!-- Secondary Moods (optional, max 2) -->
    <div class="field">
        <label>Secondary Mood (optional, max 2)</label>

        @* We show all moods grouped so user can choose up to two *@
        @foreach (var group in MoodGroups)
        {
            <div class="secondary-group">
                <div class="secondary-title">@group</div>

                <div class="mood-categories">
                    @foreach (var mood in MoodMap[group])
                    {
                        var isSelected = SecondaryMoods.Contains(mood);

                        <button type="button"
                                class="pill @(isSelected ? "selected" : "")"
                                @onclick="@(() => ToggleSecondaryMood(mood))">
                            @mood
                        </button>
                    }
                </div>
            </div>
        }

        <div class="hint">
            You can add up to two extra moods (example: Primary = Happy, Secondary = Grateful + Relaxed).
        </div>
    </div>

    <!-- Tags (pre-built + custom) -->
    <div class="field">
        <label>Tags (optional)</label>

        <!-- Pre-built tag buttons -->
        <div class="tag-cloud">
            @foreach (var tag in PrebuiltTags)
            {
                var selected = SelectedTags.Contains(tag);

                <button type="button"
                        class="tag-btn @(selected ? "selected" : "")"
                        @onclick="@(() => ToggleTag(tag))">
                    @tag
                </button>
            }
        </div>

        <!-- Custom tag input -->
        <div class="tag-add">
            <input class="input"
                   type="text"
                   placeholder="Add a custom tag and press Enter..."
                   @bind="CustomTag"
                   @onkeydown="OnCustomTagKeyDown" />

            <button type="button" class="tag-add-btn" @onclick="AddCustomTag">
                Add
            </button>
        </div>

        <!-- Selected tags preview -->
        @if (SelectedTags.Count > 0)
        {
            <div class="selected-tags">
                @foreach (var t in SelectedTags)
                {
                    <span class="selected-tag">
                        @t
                        <button type="button" class="tag-remove" @onclick="@(() => RemoveTag(t))">×</button>
                    </span>
                }
            </div>
        }
    </div>

    <!-- Markdown Content -->
    <div class="field">
        <label>Content (Markdown)</label>

        <!-- Simple toolbar for Markdown helpers -->
        <div class="editor-toolbar">
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("**bold**"))">Bold</button>
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("*italic*"))">Italic</button>
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("# Heading"))">Heading</button>
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("- List item"))">List</button>
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("> Quote"))">Quote</button>
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("`code`"))">Code</button>

            <div class="spacer"></div>

            <button type="button" class="tool-btn @(ShowPreview ? "selected" : "")" @onclick="TogglePreview">
                @(ShowPreview ? "Hide Preview" : "Preview")
            </button>
        </div>

        <!-- Markdown textarea -->
        <textarea class="content-area"
                  placeholder="Write your thoughts here..."
                  @bind="Content"></textarea>

        <!-- Preview area (simple safe preview) -->
        @if (ShowPreview)
        {
            <div class="preview">
                @((MarkupString)PreviewHtml)
            </div>
        }
    </div>

    <!-- Error message (validation, login missing, etc.) -->
    @if (!string.IsNullOrWhiteSpace(ErrorMessage))
    {
        <div class="error-box">@ErrorMessage</div>
    }
</div>

@code {
    // ----- Basic form fields -----
    private string Title { get; set; } = "";
    private DateTime EntryDate { get; set; } = DateTime.Today;
    private string Category { get; set; } = "Personal";
    private string Content { get; set; } = "";

    // ----- System-generated timestamps -----
    private DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    private DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // ----- Mood data -----
    private readonly List<string> MoodGroups = new() { "Positive", "Neutral", "Negative" };

    private readonly Dictionary<string, List<string>> MoodMap = new()
    {
        ["Positive"] = new() { "Happy", "Excited", "Relaxed", "Grateful", "Confident" },
        ["Neutral"] = new() { "Calm", "Thoughtful", "Curious", "Nostalgic", "Bored" },
        ["Negative"] = new() { "Sad", "Angry", "Stressed", "Lonely", "Anxious" }
    };

    // Primary mood (required)
    private string PrimaryMoodGroup { get; set; } = "Neutral";
    private string PrimaryMood { get; set; } = "Calm";

    // Secondary moods (optional, max 2)
    private List<string> SecondaryMoods { get; set; } = new();

    // ----- Category list -----
    private readonly List<string> Categories = new()
    {
        "Personal", "Work", "Studies", "Family", "Friends", "Health", "Self-care", "Travel", "Finance"
    };

    // ----- Tags -----
    private readonly List<string> PrebuiltTags = new()
    {
        "Work","Career","Studies","Family","Friends","Relationships","Health","Fitness","Personal Growth","Self-care",
        "Hobbies","Travel","Nature","Finance","Spirituality","Birthday","Holiday","Vacation","Celebration","Exercise",
        "Reading","Writing","Cooking","Meditation","Yoga","Music","Shopping","Parenting","Projects","Planning","Reflection"
    };

    private List<string> SelectedTags { get; set; } = new();
    private string CustomTag { get; set; } = "";

    // ----- UI helpers -----
    private bool IsSaving { get; set; } = false;
    private string ErrorMessage { get; set; } = "";

    // Markdown preview
    private bool ShowPreview { get; set; } = false;
    private string PreviewHtml => RenderMarkdownLite(Content);

    private void GoBack()
    {
        // Simple navigation back to dashboard (you can change this to /dashboard)
        Nav.NavigateTo("/dashboard");
    }

    private void SetPrimaryGroup(string group)
    {
        // When user switches group, pick the first mood in that group as default
        PrimaryMoodGroup = group;
        PrimaryMood = MoodMap[group].First();
        TouchUpdated();
    }

    private void SetPrimaryMood(string mood)
    {
        PrimaryMood = mood;
        TouchUpdated();
    }

    private void ToggleSecondaryMood(string mood)
    {
        // Prevent selecting the same mood as primary
        if (mood == PrimaryMood) return;

        if (SecondaryMoods.Contains(mood))
        {
            SecondaryMoods.Remove(mood);
        }
        else
        {
            // Enforce max 2 selections
            if (SecondaryMoods.Count >= 2) return;
            SecondaryMoods.Add(mood);
        }

        TouchUpdated();
    }

    private void ToggleTag(string tag)
    {
        if (SelectedTags.Contains(tag))
            SelectedTags.Remove(tag);
        else
            SelectedTags.Add(tag);

        TouchUpdated();
    }

    private void RemoveTag(string tag)
    {
        SelectedTags.Remove(tag);
        TouchUpdated();
    }

    private void AddCustomTag()
    {
        var tag = (CustomTag ?? "").Trim();

        if (string.IsNullOrWhiteSpace(tag))
            return;

        // Avoid duplicates (case-insensitive)
        if (!SelectedTags.Any(t => t.Equals(tag, StringComparison.OrdinalIgnoreCase)))
        {
            SelectedTags.Add(tag);
        }

        CustomTag = "";
        TouchUpdated();
    }

    private void OnCustomTagKeyDown(KeyboardEventArgs e)
    {
        // Pressing Enter adds the custom tag quickly
        if (e.Key == "Enter")
        {
            AddCustomTag();
        }
    }

    private void TogglePreview()
    {
        ShowPreview = !ShowPreview;
    }

    private void InsertMd(string snippet)
    {
        // Simple helper: append Markdown snippet to the end
        // (Later we can enhance to insert at cursor position)
        if (!string.IsNullOrWhiteSpace(Content) && !Content.EndsWith("\n"))
            Content += "\n";

        Content += snippet + "\n";
        TouchUpdated();
    }

    private void TouchUpdated()
    {
        // Updates UpdatedAt whenever user changes something
        UpdatedAt = DateTime.UtcNow;
    }

    private async Task SaveEntry()
    {
        ErrorMessage = "";

        // Must be logged in to create an entry (ties entry to UserId)
        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            ErrorMessage = "You must be logged in to save an entry.";
            Nav.NavigateTo("/login");
            return;
        }

        // Basic validation (helps you defend in viva)
        if (string.IsNullOrWhiteSpace(Title))
        {
            ErrorMessage = "Title is required.";
            return;
        }

        if (string.IsNullOrWhiteSpace(Content))
        {
            ErrorMessage = "Content is required.";
            return;
        }

        IsSaving = true;

        try
        {
            // Save only fields that exist in your current JournalEntry table
            // (We will add columns for tags/category/secondary moods later if you want.)
            var entry = new JournalEntry
            {
                Title = Title.Trim(),
                Content = Content,
                CreatedAt = CreatedAt,              // system generated
                Mood = PrimaryMoodGroup,            // store primary mood group for analytics
                UserId = UserSession.CurrentUserId.Value
            };

            DB.JournalEntries.Add(entry);
            await DB.SaveChangesAsync();

            // After save, go back to dashboard
            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Save failed: " + ex.Message;
        }
        finally
        {
            IsSaving = false;
        }
    }

    // Lightweight Markdown renderer (safe)
    // - Encodes HTML first (prevents script injection)
    // - Adds very basic formatting (**bold**, *italic*, # heading, line breaks)
    private string RenderMarkdownLite(string text)
    {
        if (string.IsNullOrEmpty(text)) return "<em>Nothing to preview yet.</em>";

        var encoded = System.Net.WebUtility.HtmlEncode(text);

        // Headings
        encoded = System.Text.RegularExpressions.Regex.Replace(
            encoded,
            @"^# (.*)$",
            "<h3>$1</h3>",
            System.Text.RegularExpressions.RegexOptions.Multiline);

        // Bold **text**
        encoded = System.Text.RegularExpressions.Regex.Replace(encoded, @"\*\*(.*?)\*\*", "<strong>$1</strong>");

        // Italic *text*
        encoded = System.Text.RegularExpressions.Regex.Replace(encoded, @"\*(.*?)\*", "<em>$1</em>");

        // Line breaks
        encoded = encoded.Replace("\n", "<br />");

        return encoded;
    }
}
