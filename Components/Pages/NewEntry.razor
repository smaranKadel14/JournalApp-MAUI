@page "/new-entry"
@page "/new-entry/{EntryId:int}"

@* New Entry page (Create + Update + Delete)
   - Only ONE entry per day per user
   - CreatedAt/UpdatedAt are system generated
   - When user changes date, we load that day's entry if it exists *@

@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.EntityFrameworkCore
@using JournalApp.Models

@inject JournalApp.Services.UserService UserSession
@inject JournalApp.Data.AppDbContext DB
@inject NavigationManager Nav

<div class="entry-container">

    <!-- Header row: Back / Title / Save / Delete -->
    <div class="header">
        <button type="button" class="back-link" @onclick="GoBack">← Back</button>

        <h1>@(IsEditMode ? "Edit Entry" : "New Entry")</h1>

        <div style="display:flex; gap:10px; align-items:center;">
            @* Show Delete only when we are editing an existing entry *@
            @if (IsEditMode)
            {
                <button type="button" class="delete-btn" @onclick="DeleteEntry" disabled="@IsSaving">
                    Delete
                </button>
            }

            <button type="button" class="save-btn" @onclick="SaveEntry" disabled="@IsSaving">
                @(IsSaving ? "Saving..." : "Save")
            </button>
        </div>
    </div>

    <!-- Info message (when entry exists for selected date) -->
    @if (!string.IsNullOrWhiteSpace(InfoMessage))
    {
        <div class="info-box">@InfoMessage</div>
    }

    <!-- System generated timestamps (read-only) -->
    <div class="meta-row">
        <div class="meta-item">
            <span class="meta-label">Created At</span>
            <span class="meta-value">@CreatedAt.ToLocalTime().ToString("g")</span>
        </div>
        <div class="meta-item">
            <span class="meta-label">Updated At</span>
            <span class="meta-value">@UpdatedAt.ToLocalTime().ToString("g")</span>
        </div>
    </div>

    <!-- Title -->
    <label class="sr-only">Title</label>
    <input class="title-input" type="text" placeholder="Enter title..." @bind="Title" />

    <!-- Date + Category row -->
    <div class="row">
        <div class="field">
            <label>Date</label>

            @* IMPORTANT: When date changes, we load that day's entry (if exists) *@
            <InputDate class="input" @bind-Value="EntryDate" @onchange="OnDateChanged" />

            <div class="hint">Only one entry is allowed per day.</div>
        </div>

        <div class="field">
            <label>Category</label>
            <select class="input" @bind="Category">
                @foreach (var c in Categories)
                {
                    <option value="@c">@c</option>
                }
            </select>
        </div>
    </div>

    <!-- Primary Mood (required) -->
    <div class="field">
        <label>Primary Mood (required)</label>

        <!-- Choose mood group -->
        <div class="mood-selector">
            @foreach (var group in MoodGroups)
            {
                <button type="button"
                        class="mood-opt @(PrimaryMoodGroup == group ? "selected" : "")"
                        @onclick="@(() => SetPrimaryGroup(group))">
                    @group
                </button>
            }
        </div>

        <!-- Choose mood category within the selected group -->
        <div class="mood-categories">
            @foreach (var mood in MoodMap[PrimaryMoodGroup])
            {
                <button type="button"
                        class="pill @(PrimaryMood == mood ? "selected" : "")"
                        @onclick="@(() => SetPrimaryMood(mood))">
                    @mood
                </button>
            }
        </div>

        <div class="hint">
            Your primary mood group is stored in DB as <b>Mood</b> (for analytics).
        </div>
    </div>

    <!-- Secondary Moods (optional, max 2) -->
    <div class="field">
        <label>Secondary Mood (optional, max 2)</label>

        @foreach (var group in MoodGroups)
        {
            <div class="secondary-group">
                <div class="secondary-title">@group</div>

                <div class="mood-categories">
                    @foreach (var mood in MoodMap[group])
                    {
                        var isSelected = SecondaryMoods.Contains(mood);

                        <button type="button"
                                class="pill @(isSelected ? "selected" : "")"
                                @onclick="@(() => ToggleSecondaryMood(mood))">
                            @mood
                        </button>
                    }
                </div>
            </div>
        }

        <div class="hint">
            Secondary moods are UI-only for now (we can add DB columns later).
        </div>
    </div>

    <!-- Tags (pre-built + custom) -->
    <div class="field">
        <label>Tags (optional)</label>

        <div class="tag-cloud">
            @foreach (var tag in PrebuiltTags)
            {
                var selected = SelectedTags.Contains(tag);

                <button type="button"
                        class="tag-btn @(selected ? "selected" : "")"
                        @onclick="@(() => ToggleTag(tag))">
                    @tag
                </button>
            }
        </div>

        <div class="tag-add">
            <input class="input"
                   type="text"
                   placeholder="Add a custom tag and press Enter..."
                   @bind="CustomTag"
                   @onkeydown="OnCustomTagKeyDown" />

            <button type="button" class="tag-add-btn" @onclick="AddCustomTag">
                Add
            </button>
        </div>

        @if (SelectedTags.Count > 0)
        {
            <div class="selected-tags">
                @foreach (var t in SelectedTags)
                {
                    <span class="selected-tag">
                        @t
                        <button type="button" class="tag-remove" @onclick="@(() => RemoveTag(t))">×</button>
                    </span>
                }
            </div>
        }
    </div>

    <!-- Markdown Content -->
    <div class="field">
        <label>Content (Markdown)</label>

        <div class="editor-toolbar">
            @* IMPORTANT: Use single quotes for snippets that include quotes to avoid Razor parsing errors *@
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("**bold**"))">Bold</button>
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("*italic*"))">Italic</button>
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("# Heading"))">Heading</button>
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("- List item"))">List</button>
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("> Quote"))">Quote</button>
            <button type="button" class="tool-btn" @onclick="@(() => InsertMd("`code`"))">Code</button>

            <div class="spacer"></div>

            <button type="button" class="tool-btn @(ShowPreview ? "selected" : "")" @onclick="TogglePreview">
                @(ShowPreview ? "Hide Preview" : "Preview")
            </button>
        </div>

        <textarea class="content-area"
                  placeholder="Write your thoughts here..."
                  @bind="Content"></textarea>

        @if (ShowPreview)
        {
            <div class="preview">
                @((MarkupString)PreviewHtml)
            </div>
        }
    </div>

    <!-- Error message -->
    @if (!string.IsNullOrWhiteSpace(ErrorMessage))
    {
        <div class="error-box">@ErrorMessage</div>
    }
</div>

@code {
    // Route param: /new-entry/5 means edit entry Id=5
    [Parameter] public int? EntryId { get; set; }

    // Tracks if we are editing existing entry (not just "new")
    private bool IsEditMode => CurrentEntryDbId.HasValue;

    // Holds currently loaded entry Id (if exists)
    private int? CurrentEntryDbId { get; set; } = null;

    // ----- Basic form fields -----
    private string Title { get; set; } = "";
    private DateTime EntryDate { get; set; } = DateTime.Today;
    private string Category { get; set; } = "Personal";
    private string Content { get; set; } = "";

    // ----- System-generated timestamps -----
    private DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    private DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // ----- Mood data -----
    private readonly List<string> MoodGroups = new() { "Positive", "Neutral", "Negative" };

    private readonly Dictionary<string, List<string>> MoodMap = new()
    {
        ["Positive"] = new() { "Happy", "Excited", "Relaxed", "Grateful", "Confident" },
        ["Neutral"] = new() { "Calm", "Thoughtful", "Curious", "Nostalgic", "Bored" },
        ["Negative"] = new() { "Sad", "Angry", "Stressed", "Lonely", "Anxious" }
    };

    // Primary mood (required)
    private string PrimaryMoodGroup { get; set; } = "Neutral";
    private string PrimaryMood { get; set; } = "Calm";

    // Secondary moods (optional, max 2)
    private List<string> SecondaryMoods { get; set; } = new();

    // ----- Category list -----
    private readonly List<string> Categories = new()
    {
        "Personal", "Work", "Studies", "Family", "Friends", "Health", "Self-care", "Travel", "Finance"
    };

    // ----- Tags -----
    private readonly List<string> PrebuiltTags = new()
    {
        "Work","Career","Studies","Family","Friends","Relationships","Health","Fitness","Personal Growth","Self-care",
        "Hobbies","Travel","Nature","Finance","Spirituality","Birthday","Holiday","Vacation","Celebration","Exercise",
        "Reading","Writing","Cooking","Meditation","Yoga","Music","Shopping","Parenting","Projects","Planning","Reflection"
    };

    private List<string> SelectedTags { get; set; } = new();
    private string CustomTag { get; set; } = "";

    // ----- UI helpers -----
    private bool IsSaving { get; set; } = false;
    private string ErrorMessage { get; set; } = "";
    private string InfoMessage { get; set; } = "";

    // Markdown preview
    private bool ShowPreview { get; set; } = false;
    private string PreviewHtml => RenderMarkdownLite(Content);

    protected override async Task OnInitializedAsync()
    {
        // Must be logged in
        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            Nav.NavigateTo("/login");
            return;
        }

        // If user opened /new-entry/{id}, load by ID
        if (EntryId.HasValue)
        {
            await LoadEntryByIdAsync(EntryId.Value);
            return;
        }

        // Otherwise, load today's entry if it exists
        await LoadEntryForDateAsync();
    }

    private void GoBack()
    {
        // Go back to dashboard
        Nav.NavigateTo("/dashboard");
    }

    private async Task OnDateChanged(ChangeEventArgs _)
    {
        // When the user changes date, load that day's entry (if exists)
        await LoadEntryForDateAsync();
    }

    private async Task LoadEntryForDateAsync()
    {
        // Reset messages
        ErrorMessage = "";
        InfoMessage = "";
        CurrentEntryDbId = null;

        // Normalize date to date-only
        var day = EntryDate.Date;
        EntryDate = day;

        var userId = UserSession.CurrentUserId!.Value;

        // Try to find an existing entry for that user + day
        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

        if (existing == null)
        {
            // Create mode: clear fields
            Title = "";
            Content = "";
            PrimaryMoodGroup = "Neutral";
            PrimaryMood = MoodMap[PrimaryMoodGroup].First();
            CreatedAt = DateTime.UtcNow;
            UpdatedAt = DateTime.UtcNow;

            return;
        }

        // Edit mode: load fields from DB
        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content;
        PrimaryMoodGroup = existing.Mood;
        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;
        EntryDate = existing.EntryDate;

        InfoMessage = "An entry already exists for this date. Saving will update it.";
    }

    private async Task LoadEntryByIdAsync(int id)
    {
        ErrorMessage = "";
        InfoMessage = "";

        var userId = UserSession.CurrentUserId!.Value;

        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == id);

        if (existing == null)
        {
            ErrorMessage = "Entry not found.";
            return;
        }

        // Load into edit mode
        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content;
        PrimaryMoodGroup = existing.Mood;
        EntryDate = existing.EntryDate;
        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;

        InfoMessage = "Editing an existing entry.";
    }

    private void SetPrimaryGroup(string group)
    {
        // When switching group, reset primary mood in that group
        PrimaryMoodGroup = group;
        PrimaryMood = MoodMap[group].First();

        TouchUpdated();
    }

    private void SetPrimaryMood(string mood)
    {
        PrimaryMood = mood;
        TouchUpdated();
    }

    private void ToggleSecondaryMood(string mood)
    {
        // Prevent selecting same as primary
        if (mood == PrimaryMood) return;

        if (SecondaryMoods.Contains(mood))
        {
            SecondaryMoods.Remove(mood);
        }
        else
        {
            // Max 2 selections
            if (SecondaryMoods.Count >= 2) return;
            SecondaryMoods.Add(mood);
        }

        TouchUpdated();
    }

    private void ToggleTag(string tag)
    {
        if (SelectedTags.Contains(tag))
            SelectedTags.Remove(tag);
        else
            SelectedTags.Add(tag);

        TouchUpdated();
    }

    private void RemoveTag(string tag)
    {
        SelectedTags.Remove(tag);
        TouchUpdated();
    }

    private void AddCustomTag()
    {
        var tag = (CustomTag ?? "").Trim();

        if (string.IsNullOrWhiteSpace(tag))
            return;

        // Avoid duplicates (case-insensitive)
        if (!SelectedTags.Any(t => t.Equals(tag, StringComparison.OrdinalIgnoreCase)))
        {
            SelectedTags.Add(tag);
        }

        CustomTag = "";
        TouchUpdated();
    }

    private void OnCustomTagKeyDown(KeyboardEventArgs e)
    {
        // Enter adds custom tag
        if (e.Key == "Enter")
        {
            AddCustomTag();
        }
    }

    private void TogglePreview()
    {
        ShowPreview = !ShowPreview;
    }

    private void InsertMd(string snippet)
    {
        // Appends helper snippet to the end (simple UX)
        if (!string.IsNullOrWhiteSpace(Content) && !Content.EndsWith("\n"))
            Content += "\n";

        Content += snippet + "\n";
        TouchUpdated();
    }

    private void TouchUpdated()
    {
        // Local UI update timestamp (real DB UpdatedAt updates on save)
        UpdatedAt = DateTime.UtcNow;
    }

    private async Task SaveEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";

        // Must be logged in
        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            ErrorMessage = "You must be logged in to save an entry.";
            Nav.NavigateTo("/login");
            return;
        }

        // Basic validation
        if (string.IsNullOrWhiteSpace(Title))
        {
            ErrorMessage = "Title is required.";
            return;
        }

        if (string.IsNullOrWhiteSpace(Content))
        {
            ErrorMessage = "Content is required.";
            return;
        }

        IsSaving = true;

        try
        {
            var userId = UserSession.CurrentUserId.Value;
            var day = EntryDate.Date;

            // If editing, update that entry
            if (CurrentEntryDbId.HasValue)
            {
                var existing = await DB.JournalEntries
                    .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

                if (existing == null)
                {
                    ErrorMessage = "Entry not found (maybe deleted).";
                    return;
                }

                // Update fields
                existing.Title = Title.Trim();
                existing.Content = Content;
                existing.Mood = PrimaryMoodGroup;

                // Keep date-only
                existing.EntryDate = day;

                // System update timestamp
                existing.UpdatedAt = DateTime.UtcNow;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            // If creating, check if entry already exists for that date
            // (This enforces "only one entry per day")
            var existingForDay = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

            if (existingForDay != null)
            {
                // Convert create into update (safe fallback)
                existingForDay.Title = Title.Trim();
                existingForDay.Content = Content;
                existingForDay.Mood = PrimaryMoodGroup;
                existingForDay.UpdatedAt = DateTime.UtcNow;

                CurrentEntryDbId = existingForDay.Id;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            // Create new entry
            var entry = new JournalEntry
            {
                Title = Title.Trim(),
                Content = Content,
                Mood = PrimaryMoodGroup,
                UserId = userId,

                // Daily date + system timestamps
                EntryDate = day,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            DB.JournalEntries.Add(entry);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Save failed: " + ex.Message;
        }
        finally
        {
            IsSaving = false;
        }
    }

    private async Task DeleteEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";

        // Only allow delete in edit mode
        if (!CurrentEntryDbId.HasValue) return;
        if (UserSession.CurrentUserId is null) return;

        try
        {
            var userId = UserSession.CurrentUserId.Value;

            // Find and remove
            var existing = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

            if (existing == null)
            {
                ErrorMessage = "Entry not found.";
                return;
            }

            DB.JournalEntries.Remove(existing);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Delete failed: " + ex.Message;
        }
    }

    // Lightweight Markdown preview (safe)
    private string RenderMarkdownLite(string text)
    {
        if (string.IsNullOrEmpty(text)) return "<em>Nothing to preview yet.</em>";

        var encoded = System.Net.WebUtility.HtmlEncode(text);

        // Headings
        encoded = System.Text.RegularExpressions.Regex.Replace(
            encoded,
            @"^# (.*)$",
            "<h3>$1</h3>",
            System.Text.RegularExpressions.RegexOptions.Multiline);

        // Bold **text**
        encoded = System.Text.RegularExpressions.Regex.Replace(encoded, @"\*\*(.*?)\*\*", "<strong>$1</strong>");

        // Italic *text*
        encoded = System.Text.RegularExpressions.Regex.Replace(encoded, @"\*(.*?)\*", "<em>$1</em>");

        // Line breaks
        encoded = encoded.Replace("\n", "<br />");

        return encoded;
    }
}
