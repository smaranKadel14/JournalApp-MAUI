@page "/new-entry"
@page "/new-entry/{EntryId:int}"

@using System.Linq
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.EntityFrameworkCore
@using Microsoft.JSInterop
@using JournalApp.Models
@using JournalApp.Components.Shared

@inject IJSRuntime JS
@inject JournalApp.Services.UserService UserSession
@inject JournalApp.Data.AppDbContext DB
@inject NavigationManager Nav

<div class="entry-container">
    <div class="entry-card">
        <div class="header">
            <button type="button" class="back-link" @onclick="GoBack">← Back</button>

            <h1>@(IsEditMode ? "Edit Entry" : "New Entry")</h1>

            <div class="header-actions">
                @if (IsEditMode)
                {
                    <button type="button"
                            class="delete-btn"
                            @onclick="ShowDeleteConfirmation"
                            disabled="@IsSaving">
                        Delete
                    </button>
                }

                <button type="button"
                        class="save-btn"
                        @onclick="SaveEntry"
                        disabled="@IsSaving">
                    @(IsSaving ? "Saving..." : "Save")
                </button>
            </div>
        </div>

        @if (!string.IsNullOrWhiteSpace(InfoMessage))
        {
            <div class="info-box">@InfoMessage</div>
        }

        <div class="meta-row">
            <div class="meta-item">
                <span class="meta-label">Created At</span>
                <span class="meta-value">@CreatedAt.ToLocalTime().ToString("g")</span>
            </div>

            <div class="meta-item">
                <span class="meta-label">Updated At</span>
                <span class="meta-value">@UpdatedAt.ToLocalTime().ToString("g")</span>
            </div>
        </div>

        <!-- Title -->
        <label class="sr-only">Title</label>
        <input class="title-input"
               type="text"
               placeholder="Enter title..."
               @bind-value="Title"
               @bind-value:event="oninput"
               @bind-value:after="TouchUpdated" />

        <div class="row">
            <div class="field">
                <label>Entry Date</label>

                <InputDate class="input"
                           Value="EntryDate"
                           ValueChanged="@(async (DateTime d) => await OnEntryDateChanged(d))"
                           ValueExpression="(() => EntryDate)" />
            </div>

            <div class="field">
                <label>Category</label>

                <select class="input"
                        @bind="Category"
                        @bind:after="TouchUpdated">
                    @foreach (var c in Categories)
                    {
                        <option value="@c">@c</option>
                    }
                </select>
            </div>
        </div>

        <div class="component-section">
            <div class="section-title">Mood</div>
            <MoodPicker MoodGroups="MoodGroups"
                        MoodMap="MoodMap"
                        @bind-PrimaryMoodGroup="PrimaryMoodGroup"
                        @bind-SecondaryMoods="SecondaryMoods" />
        </div>

        <div class="component-section">
            <div class="section-title">Tags</div>
            <TagPicker PrebuiltTags="PrebuiltTags"
                       @bind-SelectedTags="SelectedTags" />
        </div>

        <div class="field">
            <label>Entry Content</label>

            <RichTextEditor @bind-Html="Content" Placeholder="Write your journal entry..." />
        </div>

        @if (!string.IsNullOrWhiteSpace(ErrorMessage))
        {
            <div class="error-box">@ErrorMessage</div>
        }
    </div>

    <!-- Delete Confirmation Modal -->
    @if (ShowDeleteModal)
    {
        <div class="modal-overlay" @onclick="HideDeleteConfirmation">
            <div class="modal-card" @onclick:stopPropagation>
                <div class="modal-header">
                    <h3>Delete Entry</h3>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete this entry?</p>
                    <p class="modal-warning">This action cannot be undone.</p>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn-cancel" @onclick="HideDeleteConfirmation">
                        Cancel
                    </button>
                    <button type="button" class="btn-delete" @onclick="ConfirmDeleteEntry">
                        Delete Entry
                    </button>
                </div>
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public int? EntryId { get; set; }

    private bool IsEditMode => CurrentEntryDbId.HasValue;
    private int? CurrentEntryDbId { get; set; } = null;

    private string Title { get; set; } = "";
    private DateTime EntryDate { get; set; } = DateTime.Today;
    private string Category { get; set; } = "Personal"; // UI-only (for now)

    private string Content { get; set; } = "";

    private DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    private DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    private readonly List<string> MoodGroups = new() { "Positive", "Neutral", "Negative" };

    private readonly Dictionary<string, List<string>> MoodMap = new()
    {
        ["Positive"] = new() { "Happy", "Excited", "Relaxed", "Grateful", "Confident" },
        ["Neutral"]  = new() { "Calm", "Thoughtful", "Curious", "Nostalgic", "Bored" },
        ["Negative"] = new() { "Sad", "Angry", "Stressed", "Lonely", "Anxious" }
    };

    private string PrimaryMoodGroup { get; set; } = "Neutral";
    private List<string> SecondaryMoods { get; set; } = new();

    private readonly List<string> Categories = new()
    {
        "Personal", "Work", "Studies", "Family", "Friends", "Health", "Self-care", "Travel", "Finance"
    };

    private readonly List<string> PrebuiltTags = new()
    {
        "Work","Career","Studies","Family","Friends","Relationships","Health","Fitness","Personal Growth","Self-care",
        "Hobbies","Travel","Nature","Finance","Spirituality","Birthday","Holiday","Vacation","Celebration","Exercise",
        "Reading","Writing","Cooking","Meditation","Yoga","Music","Shopping","Parenting","Projects","Planning","Reflection"
    };

    private List<string> SelectedTags { get; set; } = new();

    private bool IsSaving { get; set; } = false;
    private string ErrorMessage { get; set; } = "";
    private string InfoMessage { get; set; } = "";
    private bool ShowDeleteModal { get; set; } = false;

    private string StripHtml(string html)
    {
        if (string.IsNullOrWhiteSpace(html)) return "";
        var noTags = System.Text.RegularExpressions.Regex.Replace(html, "<.*?>", string.Empty);
        return System.Net.WebUtility.HtmlDecode(noTags).Trim();
    }

    private void TouchUpdated()
    {
        UpdatedAt = DateTime.UtcNow;
    }

    // ✅ helper to load tags/moods from CSV stored in DB
    private static List<string> SplitCsv(string? csv)
    {
        if (string.IsNullOrWhiteSpace(csv)) return new();
        return csv.Split(',', StringSplitOptions.RemoveEmptyEntries)
                  .Select(x => x.Trim())
                  .Where(x => x.Length > 0)
                  .Distinct()
                  .ToList();
    }

    protected override async Task OnInitializedAsync()
    {
        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            Nav.NavigateTo("/login");
            return;
        }

        if (EntryId.HasValue)
        {
            await LoadEntryByIdAsync(EntryId.Value);
            return;
        }

        await LoadEntryForDateAsync();
    }

    private void GoBack() => Nav.NavigateTo("/dashboard");

    private void ShowDeleteConfirmation()
    {
        ShowDeleteModal = true;
    }

    private void HideDeleteConfirmation()
    {
        ShowDeleteModal = false;
    }

    private async Task ConfirmDeleteEntry()
    {
        await DeleteEntry();
    }

    private async Task OnEntryDateChanged(DateTime newDate)
    {
        EntryDate = newDate.Date;
        await LoadEntryForDateAsync();
    }

    private async Task LoadEntryForDateAsync()
    {
        ErrorMessage = "";
        InfoMessage = "";
        CurrentEntryDbId = null;

        var day = EntryDate.Date;
        var userId = UserSession.CurrentUserId!.Value;

        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

        if (existing == null)
        {
            Title = "";
            Content = "";
            PrimaryMoodGroup = "Neutral";

            SecondaryMoods = new();
            SelectedTags = new();

            CreatedAt = DateTime.UtcNow;
            UpdatedAt = DateTime.UtcNow;
            return;
        }

        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content ?? "";

        PrimaryMoodGroup = string.IsNullOrWhiteSpace(existing.Mood) ? "Neutral" : existing.Mood;
        if (!MoodMap.ContainsKey(PrimaryMoodGroup))
            PrimaryMoodGroup = "Neutral";

        // ✅ restore lists from DB (requires properties in JournalEntry model)
        SecondaryMoods = SplitCsv(existing.SecondaryMoodsCsv);
        SelectedTags = SplitCsv(existing.TagsCsv);

        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;
        EntryDate = existing.EntryDate.Date;

        InfoMessage = "An entry already exists for this date. Saving will update it.";
    }

    private async Task LoadEntryByIdAsync(int id)
    {
        ErrorMessage = "";
        InfoMessage = "";

        var userId = UserSession.CurrentUserId!.Value;

        var existing = await DB.JournalEntries
            .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == id);

        if (existing == null)
        {
            ErrorMessage = "Entry not found.";
            return;
        }

        CurrentEntryDbId = existing.Id;
        Title = existing.Title;
        Content = existing.Content ?? "";

        PrimaryMoodGroup = string.IsNullOrWhiteSpace(existing.Mood) ? "Neutral" : existing.Mood;
        if (!MoodMap.ContainsKey(PrimaryMoodGroup))
            PrimaryMoodGroup = "Neutral";

        SecondaryMoods = SplitCsv(existing.SecondaryMoodsCsv);
        SelectedTags = SplitCsv(existing.TagsCsv);

        EntryDate = existing.EntryDate.Date;
        CreatedAt = existing.CreatedAt;
        UpdatedAt = existing.UpdatedAt;

        InfoMessage = "Editing an existing entry.";
    }

    private async Task SaveEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";

        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            ErrorMessage = "You must be logged in to save an entry.";
            Nav.NavigateTo("/login");
            return;
        }

        if (string.IsNullOrWhiteSpace(Title))
        {
            ErrorMessage = "Title is required.";
            return;
        }

        if (string.IsNullOrWhiteSpace(StripHtml(Content)))
        {
            ErrorMessage = "Content is required.";
            return;
        }

        IsSaving = true;

        try
        {
            var userId = UserSession.CurrentUserId.Value;
            var day = EntryDate.Date;

            if (CurrentEntryDbId.HasValue)
            {
                var existing = await DB.JournalEntries
                    .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

                if (existing == null)
                {
                    ErrorMessage = "Entry not found (maybe deleted).";
                    return;
                }

                existing.Title = Title.Trim();
                existing.Content = Content;
                existing.Mood = PrimaryMoodGroup;
                existing.EntryDate = day;

                existing.SecondaryMoodsCsv = string.Join(",", SecondaryMoods);
                existing.TagsCsv = string.Join(",", SelectedTags);

                existing.UpdatedAt = DateTime.UtcNow;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            var existingForDay = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.EntryDate == day);

            if (existingForDay != null)
            {
                existingForDay.Title = Title.Trim();
                existingForDay.Content = Content;
                existingForDay.Mood = PrimaryMoodGroup;

                existingForDay.SecondaryMoodsCsv = string.Join(",", SecondaryMoods);
                existingForDay.TagsCsv = string.Join(",", SelectedTags);

                existingForDay.UpdatedAt = DateTime.UtcNow;

                CurrentEntryDbId = existingForDay.Id;

                await DB.SaveChangesAsync();
                Nav.NavigateTo("/dashboard");
                return;
            }

            var entry = new JournalEntry
            {
                Title = Title.Trim(),
                Content = Content,
                Mood = PrimaryMoodGroup,

                SecondaryMoodsCsv = string.Join(",", SecondaryMoods),
                TagsCsv = string.Join(",", SelectedTags),

                UserId = userId,
                EntryDate = day,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            DB.JournalEntries.Add(entry);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Save failed: " + ex.Message;
        }
        finally
        {
            IsSaving = false;
        }
    }

    private async Task DeleteEntry()
    {
        ErrorMessage = "";
        InfoMessage = "";
        ShowDeleteModal = false;

        if (!CurrentEntryDbId.HasValue) return;
        if (UserSession.CurrentUserId is null) return;

        try
        {
            var userId = UserSession.CurrentUserId.Value;

            var existing = await DB.JournalEntries
                .FirstOrDefaultAsync(e => e.UserId == userId && e.Id == CurrentEntryDbId.Value);

            if (existing == null)
            {
                ErrorMessage = "Entry not found.";
                return;
            }

            DB.JournalEntries.Remove(existing);
            await DB.SaveChangesAsync();

            Nav.NavigateTo("/dashboard");
        }
        catch (Exception ex)
        {
            ErrorMessage = "Delete failed: " + ex.Message;
        }
    }
}
