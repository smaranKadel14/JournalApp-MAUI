@page "/entries"

@* 
    ENTRIES LIST PAGE WITH PAGINATION
    - Shows paginated journal entries for the currently logged-in user
    - Search + mood filter functionality
    - Pagination controls for easy navigation
    - Each entry row is clickable and navigates to the edit page: /new-entry/{id}
    - Shows entry snippet preview with HTML stripped
*@

@using Microsoft.EntityFrameworkCore
@using JournalApp.Models
@using JournalApp.Utils

@inject JournalApp.Services.UserService UserSession
@inject JournalApp.Data.AppDbContext DB
@inject NavigationManager Nav

<div class="entries-wrapper">

    <header class="entries-header">
        <div class="left">
            <h1>Entries</h1>
            <p class="subtitle">I can browse, search, and filter all my journal entries here.</p>
        </div>

        <div class="right">
            <button class="primary-btn" @onclick="GoNewEntry">
                + New Entry
            </button>
        </div>
    </header>

    <!-- Filters row -->
    <section class="filters">
        <div class="filter-item">
            <label>Search</label>
            <input class="input"
                   placeholder="Search title or content..."
                   @bind="SearchText"
                   @bind:event="oninput"
                   @onkeydown="OnSearchKeyDown" />
        </div>

        <div class="filter-item">
            <label>Mood</label>
            <select class="input" @bind="MoodFilter">
                <option value="All">All</option>
                <option value="Positive">Positive</option>
                <option value="Neutral">Neutral</option>
                <option value="Negative">Negative</option>
            </select>
        </div>

        <div class="filter-item">
            <label>Tags</label>
            <select class="input" @bind="TagFilter">
                <option value="All">All Tags</option>
                @foreach (var tag in AvailableTags)
                {
                    <option value="@tag">@tag</option>
                }
            </select>
        </div>

        <div class="filter-item">
            <label>From Date</label>
            <InputDate class="input" @bind-Value="FromDate" />
        </div>

        <div class="filter-item">
            <label>To Date</label>
            <InputDate class="input" @bind-Value="ToDate" />
        </div>

        <div class="filter-actions">
            <button class="ghost-btn" @onclick="ApplyFiltersAsync" disabled="@IsLoading">
                @(IsLoading ? "Searching..." : "Search")
            </button>

            <button class="clear-btn" @onclick="ClearFiltersAsync" disabled="@IsLoading">
                Clear
            </button>
        </div>
    </section>

    <!-- Status / results -->
    @if (IsLoading)
    {
        <p class="status-text">Loading...</p>
    }
    else if (!string.IsNullOrWhiteSpace(ErrorMessage))
    {
        <div class="error-box">@ErrorMessage</div>
    }
    else if (AllEntries.Count == 0)
    {
        <div class="empty-state">
            <p>No entries found.</p>
            <button class="ghost-btn" @onclick="GoNewEntry">Write one now</button>
        </div>
    }
    else
    {
        <div class="list">
            @foreach (var e in PagedEntries)
            {
                <div class="item" @onclick="@(() => GoEditEntry(e.Id))">
                    <div class="item-left">
                        <div class="date">@e.EntryDate.ToString("MMMM dd, yyyy")</div>
                        <div class="title">@e.Title</div>
                        <div class="snippet">@MakeSnippet(e.Content)</div>
                    </div>

                    <div class="item-right">
                        <span class="mood-pill @MoodClass(e.Mood)">@e.Mood</span>
                    </div>
                </div>
            }
        </div>

        <!-- Pagination Controls - Always Visible -->
        <div class="pagination-wrapper">
            <div class="pagination-info">
                <span class="pagination-text">
                    Showing @((CurrentPage - 1) * PageSize + 1)-@Math.Min(CurrentPage * PageSize, TotalEntries) of @TotalEntries entries
                </span>
            </div>

            @if (TotalPages > 1)
            {
                <div class="pagination-controls">
                    <button class="pagination-btn" 
                            @onclick="GoToFirstPage" 
                            disabled="@(CurrentPage == 1 || IsLoading)">
                        « First
                    </button>

                    <button class="pagination-btn" 
                            @onclick="GoToPreviousPage" 
                            disabled="@(CurrentPage == 1 || IsLoading)">
                        ‹ Previous
                    </button>

                    @for (int i = GetStartPage(); i <= GetEndPage(); i++)
                    {
                        <button class="pagination-btn @(i == CurrentPage ? "active" : "")" 
                                @onclick="@(() => GoToPage(i))" 
                                disabled="@IsLoading">
                            @i
                        </button>
                    }

                    <button class="pagination-btn" 
                            @onclick="GoToNextPage" 
                            disabled="@(CurrentPage == TotalPages || IsLoading)">
                        Next ›
                    </button>

                    <button class="pagination-btn" 
                            @onclick="GoToLastPage" 
                            disabled="@(CurrentPage == TotalPages || IsLoading)">
                        Last »
                    </button>
                </div>
            }

            <!-- Page Size Selector - Always Visible -->
            <div class="page-size-selector">
                <label>Items per page:</label>
                <select class="input page-size-select" @bind="PageSize" @bind:after="OnPageSizeChanged">
                    <option value="5">5</option>
                    <option value="10">10</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                    <option value="25">25</option>
                </select>
            </div>
        </div>
    }
</div>

@code {
    // -----------------------
    // Page State
    // -----------------------

    private bool IsLoading { get; set; } = true;
    private string ErrorMessage { get; set; } = "";

    // I store query/filter state here
    private string SearchText { get; set; } = "";
    private string MoodFilter { get; set; } = "All";
    private string TagFilter { get; set; } = "All";
    private DateTime FromDate { get; set; } = DateTime.Today.AddMonths(-1);
    private DateTime ToDate { get; set; } = DateTime.Today;
    private List<string> AvailableTags { get; set; } = new();

    // Pagination state
    private int CurrentPage { get; set; } = 1;
    private int PageSize { get; set; } = 10; // Default page size for production
    private int TotalEntries { get; set; } = 0;
    private int TotalPages => (int)Math.Ceiling((double)TotalEntries / PageSize);

    // I store the filtered results here
    private List<JournalEntry> AllEntries { get; set; } = new();
    private List<JournalEntry> PagedEntries { get; set; } = new();

    // -----------------------
    // Lifecycle
    // -----------------------

    protected override async Task OnInitializedAsync()
    {
        // I protect this page so only logged-in users can access it.
        if (!UserSession.IsLoggedIn || UserSession.CurrentUserId is null)
        {
            Nav.NavigateTo("/login");
            return;
        }

        await LoadAvailableTagsAsync();
        await LoadEntriesAsync();
    }

    // -----------------------
    // Data Loading
    // -----------------------

    private async Task LoadAvailableTagsAsync()
    {
        try
        {
            var userId = UserSession.CurrentUserId!.Value;
            
            // Get all unique tags from user's entries
            var tags = await DB.JournalEntries
                .AsNoTracking()
                .Where(e => e.UserId == userId && !string.IsNullOrWhiteSpace(e.TagsCsv))
                .SelectMany(e => e.TagsCsv.Split(',', StringSplitOptions.RemoveEmptyEntries))
                .Select(tag => tag.Trim())
                .Where(tag => !string.IsNullOrWhiteSpace(tag))
                .Distinct()
                .OrderBy(tag => tag)
                .ToListAsync();

            AvailableTags = tags;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading tags: {ex.Message}");
            AvailableTags = new List<string>();
        }
    }

    private async Task LoadEntriesAsync()
    {
        IsLoading = true;
        ErrorMessage = "";

        try
        {
            var userId = UserSession.CurrentUserId!.Value;

            // I build the query dynamically based on filters.
            var q = DB.JournalEntries
                .AsNoTracking()
                .Where(e => e.UserId == userId);

            // Date range filter
            q = q.Where(e => e.EntryDate >= FromDate.Date && e.EntryDate <= ToDate.Date);

            // Mood filter
            if (!string.Equals(MoodFilter, "All", StringComparison.OrdinalIgnoreCase))
            {
                q = q.Where(e => e.Mood == MoodFilter);
            }

            // Tag filter
            if (!string.Equals(TagFilter, "All", StringComparison.OrdinalIgnoreCase))
            {
                q = q.Where(e => e.TagsCsv.Contains(TagFilter));
            }

            // Search filter (search in Title + Content)
            var s = (SearchText ?? "").Trim();
            if (!string.IsNullOrWhiteSpace(s))
            {
                // I use LIKE because it works well with SQLite.
                var like = $"%{s}%";
                q = q.Where(e =>
                    EF.Functions.Like(e.Title, like) ||
                    EF.Functions.Like(e.Content, like));
            }

            // Get total count for pagination
            TotalEntries = await q.CountAsync();

            // Get paged results
            AllEntries = await q
                .OrderByDescending(e => e.EntryDate)
                .Skip((CurrentPage - 1) * PageSize)
                .Take(PageSize)
                .ToListAsync();

            // Update paged entries
            PagedEntries = AllEntries;

            // If current page is beyond the last page, reset to page 1
            if (CurrentPage > 1 && PagedEntries.Count == 0)
            {
                CurrentPage = 1;
                await LoadEntriesAsync();
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = "Failed to load entries: " + ex.Message;
        }
        finally
        {
            IsLoading = false;
        }
    }

    // -----------------------
    // Filter Events
    // -----------------------

    private async Task ApplyFiltersAsync()
    {
        CurrentPage = 1; // Reset to first page when applying filters
        await LoadEntriesAsync();
    }

    private async Task ClearFiltersAsync()
    {
        // I reset filters back to default and reload the list.
        SearchText = "";
        MoodFilter = "All";
        TagFilter = "All";
        FromDate = DateTime.Today.AddMonths(-1);
        ToDate = DateTime.Today;
        CurrentPage = 1; // Reset to first page when clearing filters
        await LoadEntriesAsync();
    }

    private async Task OnSearchKeyDown(Microsoft.AspNetCore.Components.Web.KeyboardEventArgs e)
    {
        // Press Enter to search (faster UX)
        if (e.Key == "Enter")
            await ApplyFiltersAsync();
    }

    // -----------------------
    // Navigation
    // -----------------------

    private void GoNewEntry()
    {
        // I navigate to the create page (your existing route).
        Nav.NavigateTo("/new-entry");
    }

    private void GoEditEntry(int id)
    {
        // I navigate to the edit page (your existing route with id).
        Nav.NavigateTo($"/new-entry/{id}");
    }

    // -----------------------
    // Pagination Navigation
    // -----------------------

    private async Task GoToPage(int page)
    {
        if (page >= 1 && page <= TotalPages)
        {
            CurrentPage = page;
            await LoadEntriesAsync();
        }
    }

    private async Task GoToFirstPage()
    {
        await GoToPage(1);
    }

    private async Task GoToPreviousPage()
    {
        await GoToPage(CurrentPage - 1);
    }

    private async Task GoToNextPage()
    {
        await GoToPage(CurrentPage + 1);
    }

    private async Task GoToLastPage()
    {
        await GoToPage(TotalPages);
    }

    private async Task OnPageSizeChanged()
    {
        CurrentPage = 1; // Reset to first page when page size changes
        await LoadEntriesAsync();
    }

    // Helper methods for pagination display
    private int GetStartPage()
    {
        int maxVisiblePages = 5;
        int halfVisible = maxVisiblePages / 2;
        
        if (TotalPages <= maxVisiblePages)
            return 1;
        
        int start = CurrentPage - halfVisible;
        if (start < 1)
            start = 1;
        
        int end = start + maxVisiblePages - 1;
        if (end > TotalPages)
        {
            start = TotalPages - maxVisiblePages + 1;
            if (start < 1)
                start = 1;
        }
        
        return start;
    }

    private int GetEndPage()
    {
        int maxVisiblePages = 5;
        int start = GetStartPage();
        int end = start + maxVisiblePages - 1;
        
        if (end > TotalPages)
            return TotalPages;
        
        return end;
    }

    // -----------------------
    // UI helpers
    // -----------------------

    private string MakeSnippet(string html)
    {
        // I strip HTML so the list doesn't show tags like <h2> or <b>.
        var text = Util.StripHtml(html ?? "");

        if (string.IsNullOrWhiteSpace(text))
            return "";

        return text.Length > 90 ? text.Substring(0, 90) + "..." : text;
    }

    private string MoodClass(string mood)
    {
        return mood switch
        {
            "Positive" => "positive",
            "Negative" => "negative",
            _ => "neutral"
        };
    }
}
